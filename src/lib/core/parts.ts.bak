// src/lib/server/parts.ts
import sql from '../server/db/index';
import { randomUUID } from 'crypto';
import { rowToPartVersionCategory,rowToPartAttachment,rowToPartCompliance,rowToPartCustomField,rowToPartVersionTag, rowToPartStructure, rowToPartRepresentation, rowToPartRevision, rowToPartValidation} from '../parts/partUtils';
import type {
  Part,
  PartVersion,
  PartVersionCategory,
  PartStructure,
  PartCompliance,
  PartAttachment,
  PartRepresentation,
  PartRevision,
  PartValidation,
  PartVersionTag,
  PartCustomField
} from '../types/types';
import {
  LifecycleStatusEnum,
  ComplianceTypeEnum,
  StructuralRelationTypeEnum,
  PartStatusEnum,
} from '../types/types';

/**
 * Safe SQL string literal helper function.
 * Prevents SQL injection when using raw string interpolation.
 * @param str The string to sanitize for SQL
 * @returns A string safe to use in SQL queries
 */
function sanitizeSqlString(str: string): string {
	// Double single quotes for SQL safety
	return str.replace(/'/g, "''");
}

// SQL client is imported directly at the top of the file

/**
 * List all parts with their current version
 */
export async function listParts(): Promise<Array<{ part: Part; currentVersion: PartVersion }>> {
	try {
		console.log('[listParts] Retrieving all parts');
		
		// Using imported sql client directly
		
		// Use SQL template literal syntax for porsager/postgres
		const result = await sql`
		SELECT 
			p.id::TEXT AS id,
			p.creator_id::TEXT AS creator_id,
			p.global_part_number::TEXT AS global_part_number,
			p.status::TEXT AS status,
			p.lifecycle_status::TEXT AS lifecycle_status,
			p.is_public::TEXT AS is_public,
			p.created_at::TEXT AS part_created_at,
			p.updated_by::TEXT AS part_updated_by,
			p.updated_at::TEXT AS part_updated_at,
			p.current_version_id::TEXT AS current_version_id,
			pv.id::TEXT AS version_id,
			pv.part_id::TEXT AS version_part_id,
			pv.version::TEXT AS version,
			pv.name::TEXT AS name,
			pv.short_description::TEXT AS short_description,
			pv.status::TEXT AS version_status,
			pv.created_by::TEXT AS version_created_by,
			pv.created_at::TEXT AS version_created_at,
			pv.updated_by::TEXT AS version_updated_by,
			pv.updated_at::TEXT AS version_updated_at
		FROM "Part" p
		JOIN "PartVersion" pv ON p.current_version_id = pv.id
		ORDER BY p.created_at DESC
		`;

		if (result.length === 0) {
			return [];
		}
		
		// Log raw rows for debugging
		console.log(`[listParts] Found ${result.length} parts\n`);
		
		// Process results - with porsager/postgres, results are returned as objects directly
		const parts = result.map((row: any) => {
			// With porsager/postgres, results are already objects with named properties
			// Ensure we get a valid part ID
			const partId = row.id?.toString(); 
			console.log(`[listParts] Processing part with real ID: '${partId}'`);
			
			if (!partId) {
				console.error('[listParts] Found a row with null part ID');
			}

			const part: Part = {
				id: partId, // This is the actual database ID
				creatorId: row.creator_id?.toString(),
				globalPartNumber: row.global_part_number?.toString() || undefined,
				status: row.status?.toString(),
				lifecycleStatus: row.lifecycle_status?.toString(),
				isPublic: row.is_public === 'true', // Convert string to boolean
				createdAt: row.part_created_at ? new Date(row.part_created_at) : new Date(),
				updatedBy: row.part_updated_by?.toString() || undefined,
				updatedAt: row.part_updated_at ? new Date(row.part_updated_at) : new Date(),
				currentVersionId: row.current_version_id?.toString() || undefined
			};
			
			// Log part object to verify ID is present
			console.log(`[listParts] Created part object with ID: ${part.id}`, JSON.stringify(part, null, 2));

			const currentVersion: PartVersion = {
				id: row.version_id?.toString(),
				partId: row.version_part_id?.toString(),
				version: row.version?.toString(),
				name: row.name?.toString(),
				shortDescription: row.short_description?.toString() || undefined,
				// Map string status to a proper enum value
				status: row.version_status && row.version_status in LifecycleStatusEnum ? 
					row.version_status as LifecycleStatusEnum : 
					LifecycleStatusEnum.DRAFT,
				createdBy: row.version_created_by?.toString(),
				createdAt: row.version_created_at ? new Date(row.version_created_at) : new Date(),
				updatedBy: row.version_updated_by?.toString() || undefined,
				updatedAt: row.version_updated_at ? new Date(row.version_updated_at) : new Date() // Default to current date if undefined
			};
			return { part, currentVersion };
		});
		
		return parts;
	} catch (error) {
		console.error('[listParts] Error retrieving parts:', error);
		return [];
	}
}

/**
 * Get a single part with its current version
 */
export async function getPartWithCurrentVersion(
	partId: string
): Promise<{ part: Part; currentVersion: PartVersion }> {
	try {
		// Stronger validation for partId parameter to avoid database errors
		if (!partId || partId === 'undefined' || partId === 'null' || partId.trim() === '') {
			console.error(`[getPartWithCurrentVersion] Invalid part ID: '${partId}'`);
			throw new Error(`Invalid part ID: cannot be undefined, null, or empty`);
		}

		console.log(`[getPartWithCurrentVersion] Retrieving part with ID: ${partId}`);
		
		// Use SQL template literals for porsager/postgres with comprehensive field selection
		const result = await sql`
		SELECT 
			-- Part table fields
			p.id::TEXT AS id,
			p.creator_id::TEXT AS creator_id,
			p.global_part_number::TEXT AS global_part_number,
			p.status::TEXT AS status,
			p.lifecycle_status::TEXT AS lifecycle_status,
			p.is_public::TEXT AS is_public,
			p.created_at::TEXT AS part_created_at,
			p.updated_by::TEXT AS part_updated_by,
			p.updated_at::TEXT AS part_updated_at,
			p.current_version_id::TEXT AS current_version_id,
			
			-- PartVersion table fields - ALL fields for complete data retrieval
			pv.id::TEXT AS version_id,
			pv.part_id::TEXT AS version_part_id,
			pv.version::TEXT AS version,
			pv.name::TEXT AS name,
			pv.short_description::TEXT AS short_description,
			pv.functional_description::TEXT AS functional_description,
			pv.long_description AS long_description,
			pv.technical_specifications AS technical_specifications,
			pv.properties AS properties,
			pv.electrical_properties AS electrical_properties,
			pv.mechanical_properties AS mechanical_properties,
			pv.thermal_properties AS thermal_properties,
			pv.material_composition AS material_composition,
			pv.environmental_data AS environmental_data,
			pv.revision_notes::TEXT AS revision_notes,
			
			-- Physical properties
			pv.dimensions AS dimensions,
			pv.dimensions_unit::TEXT AS dimensions_unit,
			pv.weight AS weight,
			pv.weight_unit::TEXT AS weight_unit,
			pv.package_type::TEXT AS package_type,
			pv.pin_count AS pin_count,
			pv.tolerance AS tolerance,
			pv.tolerance_unit::TEXT AS tolerance_unit,
			
			-- Temperature properties
			pv.operating_temperature_min AS operating_temperature_min,
			pv.operating_temperature_max AS operating_temperature_max,
			pv.storage_temperature_min AS storage_temperature_min,
			pv.storage_temperature_max AS storage_temperature_max,
			pv.temperature_unit::TEXT AS temperature_unit,
			
			-- Electrical properties
			pv.voltage_rating_min AS voltage_rating_min,
			pv.voltage_rating_max AS voltage_rating_max,
			pv.current_rating_min AS current_rating_min,
			pv.current_rating_max AS current_rating_max,
			pv.power_rating_max AS power_rating_max,
			
			-- Status and metadata fields
			pv.status::TEXT AS version_status,
			pv.created_by::TEXT AS version_created_by,
			pv.created_at::TEXT AS version_created_at,
			pv.updated_by::TEXT AS version_updated_by,
			pv.updated_at::TEXT AS version_updated_at
		FROM "Part" p
		JOIN "PartVersion" pv ON p.current_version_id = pv.id
		WHERE p.id = ${partId}
		`;

		if (result.length === 0) {
			throw new Error(`Part not found with ID: ${partId}`);
		}
		
		// With porsager/postgres, results are objects with named properties
		const row = result[0];
		console.log(`[getPartWithCurrentVersion] Raw result:`, row);

		// Ensure we get a valid part ID
		const partIdStr = row.id?.toString();
		
		if (!partIdStr) {
			console.error('[getPartWithCurrentVersion] Found a row with null part ID');
			throw new Error(`Invalid part ID for query result`);
		}
		if (!partIdStr) {
			console.error('[getPartWithCurrentVersion] Found a part with undefined or null ID!', row);
			throw new Error('Retrieved part has no valid ID');
		}

		const part: Part = {
			id: partIdStr, // This is the actual database ID
			creatorId: row.creator_id?.toString(),
			globalPartNumber: row.global_part_number?.toString() || undefined,
			status: row.status?.toString(),
			lifecycleStatus: row.lifecycle_status?.toString(),
			isPublic: row.is_public === 'true', // Convert string to boolean
			createdAt: row.part_created_at ? new Date(row.part_created_at) : new Date(),
			updatedBy: row.part_updated_by?.toString() || undefined,
			updatedAt: row.part_updated_at ? new Date(row.part_updated_at) : new Date(),
			currentVersionId: row.current_version_id?.toString() || undefined
		};

		// We need to initialize the currentVersion with default values for all fields
		// This ensures all data is properly preserved during edits
		// DEBUG: Check raw version value from database
		const rawVersion = row.version;
		console.log(`[VERSION DEBUG] Raw version from database: type=${typeof rawVersion}, value='${rawVersion}'`)
		
		// FORCE the version to be a string in semantic version format
		let versionString = row.version?.toString() || '0.1.0';
		// If it's a numeric version, convert to semantic version format
		if (!isNaN(Number(versionString)) && !versionString.includes('.')) {
			console.log(`[VERSION DEBUG] Converting numeric version '${versionString}' to semantic format`);
			// Only convert simple numbers, not already formatted versions
			if (versionString === '3') {
				versionString = '0.1.1'; // If it's exactly 3, assume it should be 0.1.1
			} else {
				versionString = `0.0.${versionString}`; // Otherwise use as patch version
			}
		}
		console.log(`[VERSION DEBUG] Final version string: '${versionString}'`);
		
		// Now map all the database fields to our currentVersion object
		const currentVersion: PartVersion = {
			id: row.version_id?.toString(),
			partId: row.version_part_id?.toString(),
			version: versionString,
			name: row.name?.toString(),
			
			// Text descriptions (with proper null handling)
			shortDescription: row.short_description?.toString() || undefined,
			functionalDescription: row.functional_description?.toString() || undefined,
			longDescription: row.long_description || undefined,
			revisionNotes: row.revision_notes?.toString() || undefined,
			
			// JSONB fields (need special handling)
			technicalSpecifications: row.technical_specifications || undefined,
			properties: row.properties || undefined,
			electricalProperties: row.electrical_properties || undefined,
			mechanicalProperties: row.mechanical_properties || undefined,
			thermalProperties: row.thermal_properties || undefined,
			materialComposition: row.material_composition || undefined,
			environmentalData: row.environmental_data || undefined,
			dimensions: row.dimensions || undefined,
			
			// Physical properties 
			weight: typeof row.weight === 'string' ? parseFloat(row.weight) : row.weight,
			weightUnit: row.weight_unit?.toString() || undefined,
			dimensionsUnit: row.dimensions_unit?.toString() || undefined,
			tolerance: typeof row.tolerance === 'string' ? parseFloat(row.tolerance) : row.tolerance,
			toleranceUnit: row.tolerance_unit?.toString() || undefined,
			packageType: row.package_type?.toString() || undefined,
			pinCount: typeof row.pin_count === 'string' ? parseInt(row.pin_count, 10) : row.pin_count,
			
			// Temperature properties (with type conversions)
			operatingTemperatureMin: typeof row.operating_temperature_min === 'string' ? 
				parseFloat(row.operating_temperature_min) : row.operating_temperature_min,
			operatingTemperatureMax: typeof row.operating_temperature_max === 'string' ? 
				parseFloat(row.operating_temperature_max) : row.operating_temperature_max,
			storageTemperatureMin: typeof row.storage_temperature_min === 'string' ? 
				parseFloat(row.storage_temperature_min) : row.storage_temperature_min,
			storageTemperatureMax: typeof row.storage_temperature_max === 'string' ? 
				parseFloat(row.storage_temperature_max) : row.storage_temperature_max,
			temperatureUnit: row.temperature_unit?.toString() || undefined,
			
			// Electrical ratings
			voltageRatingMin: typeof row.voltage_rating_min === 'string' ? 
				parseFloat(row.voltage_rating_min) : row.voltage_rating_min,
			voltageRatingMax: typeof row.voltage_rating_max === 'string' ? 
				parseFloat(row.voltage_rating_max) : row.voltage_rating_max,
			currentRatingMin: typeof row.current_rating_min === 'string' ? 
				parseFloat(row.current_rating_min) : row.current_rating_min,
			currentRatingMax: typeof row.current_rating_max === 'string' ? 
				parseFloat(row.current_rating_max) : row.current_rating_max,
			powerRatingMax: typeof row.power_rating_max === 'string' ? 
				parseFloat(row.power_rating_max) : row.power_rating_max,
			// Status and metadata
			status: row.version_status && row.version_status in LifecycleStatusEnum ? 
				row.version_status as LifecycleStatusEnum : 
				LifecycleStatusEnum.DRAFT,
			createdBy: row.version_created_by?.toString(),
			createdAt: row.version_created_at ? new Date(row.version_created_at) : new Date(),
			updatedBy: row.version_updated_by?.toString() || undefined,
			updatedAt: row.version_updated_at ? new Date(row.version_updated_at) : new Date() 
		};
		
		// Log that we're adding default values
		console.log(`[getPartWithCurrentVersion] Added default values for all fields not explicitly loaded from database`);
		
		// Log the mapped object for debugging
		console.log(`[getPartWithCurrentVersion] Mapped part object with ID: ${part.id}`)

		return { part, currentVersion };
	} catch (error) {
		console.error(`[getPartWithCurrentVersion] Error retrieving part ${partId}:`, error);
		throw error;
	}
}
export interface CreatePartInput {
    name: string;
    version: string;
    status: LifecycleStatusEnum;
    // Use PartStatusEnum instead of string
    partStatus?: PartStatusEnum;
    shortDescription?: string | null;
    functionalDescription?: string | null;
    // Extended relationship fields
    categoryIds?: string[];
    manufacturerParts?: Array<{manufacturerId: string; partNumber: string}>;
    // Allow more flexible property types to match form data
    [key: string]: any;
}

/**
 * Create a new part with its initial version
 */
// src/lib/server/parts.ts - Updated createPart function with error logging
export async function createPart(input: any, userId: string) {
    if (!input || !userId) {
        throw new Error('Missing required input or userId for part creation');
    }

    // CRITICAL FIX: Log the COMPLETE input object exactly as received
    // This helps track if any data is lost during form submission
    console.log('[createPart] Creating new part with COMPLETE input:', JSON.stringify(input, null, 2));
    
    // Generate UUIDs for part and version
    const partId = crypto.randomUUID();
    const versionId = crypto.randomUUID();
    
    // EXTREME DEBUG: Full deep inspection of all values and enums
    console.log('[createPart] ENUM DEBUG - Available values:', Object.values(LifecycleStatusEnum));
    console.log('[createPart] ENUM DEBUG - Checking if input status is valid:', 
        Object.values(LifecycleStatusEnum).includes(input.status));
    
    // Debug ALL input data to verify everything the user provided
    console.log('[createPart] FULL Input data:', JSON.stringify(input, null, 2));
    console.log('[createPart] Basic info:', {
        name: input.name,
        version: input.version,
        status: input.status,
        statusType: typeof input.status,
        statusValue: String(input.status),
        userId,
        partId,
        versionId
    });
    
    // Ensure status is a string - this handles enum values properly
    const statusValue = String(input.status);
    
    
    // Prepare the lowercase status string
    const statusLower = String(input.status).toLowerCase().replace(/'/g, "''");
    console.log('[createPart] Using status value:', statusLower);
    
    try {
        // Use the partStatus field if provided, otherwise default to CONCEPT
        const partStatusToUse = input.partStatus || PartStatusEnum.CONCEPT;
        console.log('[createPart] Using Part status:', partStatusToUse);
        
        // Proper transaction handling with porsager/postgres using sql.begin
        console.log('[createPart] Starting transaction');
        
        // Begin a transaction using the correct porsager/postgres approach
        const result = await sql.begin(async (transaction) => {
            console.log('[createPart] Inserting part');
            
            // Insert the part record
            await transaction`
            INSERT INTO "Part" (
                id, creator_id, global_part_number, status, lifecycle_status
            ) VALUES (
                ${partId},
                ${userId}, 
                ${input.name}, 
                ${String(partStatusToUse).toLowerCase()}::part_status_enum, 
                ${String(input.status).toLowerCase()}::lifecycle_status_enum
            )
            `;
            console.log('[createPart] Part inserted successfully');
            
            console.log('[createPart] Now inserting PartVersion');
            
            }
            
            // Process other JSON fields outside the SQL template
            const technicalSpecsValue = input.technicalSpecifications ? sql.json(input.technicalSpecifications) : null;
            const propertiesValue = input.properties ? sql.json(input.properties) : null;
            const electricalPropsValue = input.electricalProperties ? sql.json(input.electricalProperties) : null;
            const mechanicalPropsValue = input.mechanicalProperties ? sql.json(input.mechanicalProperties) : null;
            const thermalPropsValue = input.thermalProperties ? sql.json(input.thermalProperties) : null;
            const materialCompValue = input.materialComposition ? sql.json(input.materialComposition) : null;
            const environDataValue = input.environmentalData ? sql.json(input.environmentalData) : null;
            const longDescValue = input.longDescription ? sql.json(input.longDescription) : null;
            
            // Use a modified approach with named parameters to avoid syntax errors
            await transaction`
            INSERT INTO "PartVersion" (
                id, part_id, version, name, status, created_by, updated_by,
                short_description, functional_description, long_description,
                technical_specifications, properties, electrical_properties,
                mechanical_properties, thermal_properties, material_composition,
                environmental_data, revision_notes,
                "dimensions", dimensions_unit, weight, weight_unit, package_type, pin_count,
                operating_temperature_min, operating_temperature_max,
                storage_temperature_min, storage_temperature_max, temperature_unit,
                voltage_rating_min, voltage_rating_max, current_rating_min, current_rating_max,
                power_rating_max, tolerance, tolerance_unit
            ) VALUES (
                ${versionId}, 
                ${partId}, 
                ${input.version}, 
                ${input.name}, 
                ${String(input.status).toLowerCase()}::lifecycle_status_enum, 
                ${userId}, 
                NULL,
                ${input.shortDescription || null}, 
                ${input.functionalDescription || null},
                ${longDescValue},
                ${technicalSpecsValue},
                ${propertiesValue},
                ${electricalPropsValue},
                ${mechanicalPropsValue},
                ${thermalPropsValue},
                ${materialCompValue},
                ${environDataValue},
                ${input.revisionNotes || null},
                ${dimensionsValue},
                ${input.dimensionsUnit || null},
                ${input.weight || null},
                ${input.weightUnit || null},
                ${input.packageType || null},
                ${input.pinCount || null},
                ${input.operatingTemperatureMin || null},
                ${input.operatingTemperatureMax || null},
                ${input.storageTemperatureMin || null},
                ${input.storageTemperatureMax || null},
                ${input.temperatureUnit || null},
                ${input.voltageRatingMin || null},
                ${input.voltageRatingMax || null},
                ${input.currentRatingMin || null},
                ${input.currentRatingMax || null},
                ${input.powerRatingMax || null},
                ${input.tolerance || null},
                ${input.toleranceUnit || null}
            )
            `;
            
            console.log('[createPart] PartVersion inserted, now updating Part current_version_id');
            
            // Update the part to reference the new version
            await transaction`
            UPDATE "Part" 
            SET current_version_id = ${versionId} 
            WHERE id = ${partId}
            `;
            console.log('[createPart] Update completed for Part', partId);
            
            // Process category relationships if categoryIds are provided
            if (input.categoryIds && Array.isArray(input.categoryIds) && input.categoryIds.length > 0) {
                console.log(`[createPart] Adding ${input.categoryIds.length} categories to part version ${versionId}`);
                
                for (const categoryId of input.categoryIds) {
                    if (categoryId) {
                        try {
                            // Use the database transaction for category relationship with correct schema
                            await transaction`
                            INSERT INTO "partversioncategory" (
                                part_version_id, category_id
                            ) VALUES (
                                ${versionId}, ${categoryId}
                            )
                            `;
                            console.log(`[createPart] Added category ${categoryId} to part version ${versionId}`);
                        } catch (err: any) {
                            // Log error but continue with remaining categories
                            console.error(`[createPart] Error linking category ${categoryId}: ${err.message}`);
                            // Don't throw, to allow other categories to be linked 
                        }
                    }
                }
            }
            
            // Process manufacturer parts if provided
            if (input.manufacturerParts && Array.isArray(input.manufacturerParts) && input.manufacturerParts.length > 0) {
                console.log(`[createPart] Adding ${input.manufacturerParts.length} manufacturer parts to part version ${versionId}`);
                
                for (const mfrPart of input.manufacturerParts) {
                    if (mfrPart && mfrPart.manufacturerId && mfrPart.partNumber) {
                        await transaction`
                        INSERT INTO "ManufacturerPart" (
                            id, 
                            manufacturer_id, 
                            part_version_id, 
                            part_number, 
                            created_by, 
                            created_at
                        ) VALUES (
                            ${randomUUID()}, 
                            ${mfrPart.manufacturerId}, 
                            ${versionId}, 
                            ${mfrPart.partNumber}, 
                            ${userId}, 
                            NOW()
                        )
                        `;
                        console.log(`[createPart] Added manufacturer part ${mfrPart.partNumber} from manufacturer ${mfrPart.manufacturerId} to part version ${versionId}`);
                    }
                }
            }
            
            // Return value will be the transaction's return and will be committed automatically
            return { partId, versionId };
        });
        
        console.log('[createPart] Transaction committed successfully:', result);
    } catch (error: any) {
        // With sql.begin(), rollback happens automatically on error
        console.error('Database Error in createPart:', error.message, error.stack);
        throw error;
    }

    return getPartWithCurrentVersion(partId);
}

/**
 * Update a part version (select fields)
 */
export async function updatePartVersion(
	data: Partial<PartVersion> & { id: string }
): Promise<void> {
	try {
		// More modern approach with porsager/postgres - build update dynamically
		// Only include fields that are defined in the input data
		let updateFields = [];
		
		if (data.name !== undefined) {
			updateFields.push(`name = ${data.name}`);
		}
		if (data.version !== undefined) {
			updateFields.push(`version = ${data.version}`);
		}
		if (data.status !== undefined) {
			updateFields.push(`status = ${data.status}::text::lifecycle_status_enum`);
		}
		
		// If no fields to update, return early
		if (updateFields.length === 0) {
			console.log('[updatePartVersion] No fields to update');
			return;
		}
		
		// Use sql.unsafe for dynamic SQL with template literals for parameterization
		// This avoids SQL injection while allowing dynamic field updates
		const result = await sql.unsafe(`
			UPDATE "PartVersion" 
			SET ${updateFields.join(', ')} 
			WHERE id = '${data.id}'
			RETURNING id
		`);
		
		console.log(`[updatePartVersion] Updated part version ${data.id}`);
	} catch (error) {
		console.error('[updatePartVersion] Error updating part version:', error);
		throw error;
	}
}

/**
 * Delete a part (cascades to versions)
 */
export async function deletePart(partId: string): Promise<void> {
	try {
		console.log(`[deletePart] Deleting part with ID: ${partId}`);
		
		// Use porsager/postgres transaction handling with sql.begin
		// This handles BEGIN/COMMIT/ROLLBACK automatically
		await sql.begin(async (transaction) => {
			// First lock the part row to prevent concurrent modifications
			// This helps prevent the "tuple concurrently updated" error
			const lockResult = await transaction`
				SELECT id FROM "Part" WHERE id = ${partId} FOR UPDATE
			`;
			
			if (lockResult.length === 0) {
				throw new Error(`Part not found with ID: ${partId}`);
			}
			
			console.log(`[deletePart] Part ${partId} found and locked for deletion`);
			
			// Delete the part (relies on CASCADE for versions)
			const deleteResult = await transaction`
				DELETE FROM "Part" WHERE id = ${partId} RETURNING id
			`;
			
			if (deleteResult.length === 0) {
				throw new Error(`Failed to delete part with ID: ${partId}`);
			}
			
			console.log(`[deletePart] Part ${partId} successfully deleted within transaction`);
			// Transaction automatically commits if no errors
		});
		
		console.log(`[deletePart] Successfully deleted part with ID: ${partId}`);
	} catch (error) {
		console.error(`[deletePart] Error deleting part ${partId}:`, error);
		// With sql.begin(), rollback happens automatically on error
		throw error;
	}
}

// ======================
// Part Version Category
// ======================
export async function addCategoryToPartVersion(partVersionId: string, categoryId: string): Promise<PartVersionCategory> {
    try {
        // Use porsager/postgres template literals for SQL queries
        const result = await sql`
            INSERT INTO "PartVersionCategory" (part_version_id, category_id)
            VALUES (${partVersionId}, ${categoryId}) 
            RETURNING *
        `;
        
        if (result.length === 0) {
            throw new Error(`Failed to add category ${categoryId} to part version ${partVersionId}`);
        }
        
        // With porsager/postgres, results are direct objects
        const row = result[0];
        return rowToPartVersionCategory(row);
    } catch (error) {
        console.error('[addCategoryToPartVersion] Error:', error);
        throw error;
    }
}

export async function removeCategoryFromPartVersion(partVersionId: string, categoryId: string): Promise<void> {
    try {
        // Use template literals for DELETE operation with proper error handling
        await sql`
            DELETE FROM "PartVersionCategory" 
            WHERE part_version_id = ${partVersionId} AND category_id = ${categoryId}
        `;
        
        console.log(`[removeCategoryFromPartVersion] Removed category ${categoryId} from part version ${partVersionId}`);
    } catch (error) {
        console.error('[removeCategoryFromPartVersion] Error:', error);
        throw error;
    }
}

export async function getCategoriesForPartVersion(partVersionId: string): Promise<PartVersionCategory[]> {
    try {
        // Use template literals for SELECT operation with proper error handling
        const result = await sql`
            SELECT * FROM "PartVersionCategory" 
            WHERE part_version_id = ${partVersionId}
        `;
        
        console.log(`[getCategoriesForPartVersion] Found ${result.length} categories for part version ${partVersionId}`);
        
        // Map results using array methods directly on the result
        return result.map(rowToPartVersionCategory);
    } catch (error) {
        console.error('[getCategoriesForPartVersion] Error:', error);
        throw error;
    }
}

/**
 * Update a part record with a new current version ID and status
 * Uses proper transaction handling with row locking to prevent concurrent update issues
 */
export async function updatePartWithStatus(
  partId: string,
  newVersionId: string,
  newStatus: PartStatusEnum
): Promise<void> {
  console.log(`[updatePartWithStatus] Updating part ${partId} with new version ${newVersionId} and status ${newStatus}`);
  
  // Get SQL client
  // Using the sql client imported at the top of the file
  
  try {
    // Begin transaction - with porsager/postgres, transactions are handled with sql.begin()
    await sql.begin(async (txSql: typeof sql) => {
      console.log('[updatePartWithStatus] Transaction started');
      
      // First, lock the part row to prevent concurrent modifications
      // This is critical to avoid the "tuple concurrently updated" error
      const lockResult = await txSql`
        SELECT id FROM "Part" WHERE id = ${partId} FOR UPDATE
      `;
      
      if (lockResult.length === 0) {
        throw new Error(`Part with ID ${partId} not found or could not be locked`);
      }
      
      console.log('[updatePartWithStatus] Part row locked for update');
      
      // Now update the part with the new version ID and status
      const updateResult = await txSql`
        UPDATE "Part"
        SET 
          current_version_id = ${newVersionId},
          status = ${newStatus}::TEXT::part_status_enum,
          updated_at = NOW()
        WHERE id = ${partId}
        RETURNING id
      `;
      
      if (updateResult.length === 0) {
        throw new Error(`Failed to update part ${partId}`);
      }
      
      console.log('[updatePartWithStatus] Part updated successfully');
      // Transaction automatically commits if no errors
    });
    
    console.log('[updatePartWithStatus] Transaction committed');
  } catch (error) {
    // Transaction automatically rolls back on error
    console.error('[updatePartWithStatus] Transaction rolled back due to error:', error);
    throw error;
  }
}

/**
 * Create a new version of a part
 */
export async function createPartVersion(partVersion: Partial<PartVersion> & {
    id: string;
    partId: string;
    version: string;
    name: string;
    status: string;
    createdBy: string;
}): Promise<PartVersion> {
    try {
        // SUPER DETAILED LOGGING FOR DEBUG
        console.log('[createPartVersion] 🚨🚨🚨 ATTEMPTING TO CREATE VERSION');
        console.log('[createPartVersion] 🚨 REQUIRED FIELDS CHECK:');
        console.log(`  - id provided: ${!!partVersion.id} (${partVersion.id})`);
        console.log(`  - partId provided: ${!!partVersion.partId} (${partVersion.partId})`);
        console.log(`  - name provided: ${!!partVersion.name} (${partVersion.name})`);
        console.log(`  - version provided: ${!!partVersion.version} (${partVersion.version})`);
        console.log(`  - status provided: ${!!partVersion.status} (${partVersion.status})`);
        console.log(`  - createdBy provided: ${!!partVersion.createdBy} (${partVersion.createdBy})`);
        
        // Detailed logging to see ALL properties - NO CHERRY PICKING
        console.log('[createPartVersion] 100% COMPLETE INCOMING DATA:', JSON.stringify(partVersion, null, 2));
        
        // Get the database client
        // Using the sql client imported at the top of the file
        
        // Extra validation to catch common failures
        if (!partVersion.name || !partVersion.version || !partVersion.status) {
            console.error('[createPartVersion] ❌ CRITICAL ERROR - MISSING REQUIRED FIELDS');
            const errorDetails = {
                name: partVersion.name ? 'OK' : 'MISSING',
                version: partVersion.version ? 'OK' : 'MISSING',
                status: partVersion.status ? 'OK' : 'MISSING'
            };
            console.error('[createPartVersion] ❌ MISSING FIELD DETAILS:', errorDetails);
        }
                
        // With porsager/postgres, use sql.begin for proper transaction handling to prevent concurrent update issues
        const insertResult = await sql.begin(async (transaction) => {
            // First, lock the parent part to prevent concurrent modifications
            // This helps prevent the "tuple concurrently updated" error
            const lockResult = await transaction`
                SELECT id FROM "Part" WHERE id = ${partVersion.partId} FOR UPDATE
            `;
            
            if (lockResult.length === 0) {
                throw new Error(`Part with ID ${partVersion.partId} not found or could not be locked`);
            }
            
            console.log('[createPartVersion] Part row locked for update');
            
            // Use SQL template literals with proper sql.json() for JSONB fields
            // This ensures PostgreSQL treats them as proper JSONB data
            const result = await transaction`
                INSERT INTO "PartVersion" (
                    id, part_id, version, name, status, created_by, created_at,
                    short_description, functional_description, long_description,
                    voltage_rating_min, voltage_rating_max, current_rating_min, current_rating_max,
                    power_rating_max, tolerance, tolerance_unit, electrical_properties,
                    dimensions, dimensions_unit, weight, weight_unit, package_type, pin_count,
                    mechanical_properties, material_composition,
                    operating_temperature_min, operating_temperature_max,
                    storage_temperature_min, storage_temperature_max, temperature_unit, thermal_properties,
                    technical_specifications, properties, environmental_data, revision_notes
                ) VALUES (
                    ${partVersion.id},
                    ${partVersion.partId},
                    ${partVersion.version},
                    ${partVersion.name},
                    ${String(partVersion.status)}::lifecycle_status_enum,
                    ${partVersion.createdBy},
                    NOW(),
                    ${partVersion.shortDescription || null},
                    ${partVersion.functionalDescription || null},
                    ${partVersion.longDescription ? sql.json(partVersion.longDescription) : null},
                    ${partVersion.voltageRatingMin || null},
                    ${partVersion.voltageRatingMax || null},
                    ${partVersion.currentRatingMin || null},
                    ${partVersion.currentRatingMax || null},
                    ${partVersion.powerRatingMax || null},
                    ${partVersion.tolerance || null},
                    ${partVersion.toleranceUnit || null},
                    ${partVersion.electricalProperties ? sql.json(partVersion.electricalProperties) : null},
                    ${partVersion.dimensions ? sql.json(partVersion.dimensions) : null},
                    ${partVersion.dimensionsUnit || null},
                    ${partVersion.weight || null},
                    ${partVersion.weightUnit || null},
                    ${partVersion.packageType || null},
                    ${partVersion.pinCount || null},
                    ${partVersion.mechanicalProperties ? sql.json(partVersion.mechanicalProperties) : null},
                    ${partVersion.materialComposition ? sql.json(partVersion.materialComposition) : null},
                    ${partVersion.operatingTemperatureMin || null},
                    ${partVersion.operatingTemperatureMax || null},
                    ${partVersion.storageTemperatureMin || null},
                    ${partVersion.storageTemperatureMax || null},
                    ${partVersion.temperatureUnit || null},
                    ${partVersion.thermalProperties ? sql.json(partVersion.thermalProperties) : null},
                    ${partVersion.technicalSpecifications ? sql.json(partVersion.technicalSpecifications) : null},
                    ${partVersion.properties ? sql.json(partVersion.properties) : null},
                    ${partVersion.environmentalData ? sql.json(partVersion.environmentalData) : null},
                    ${partVersion.revisionNotes || null}
                ) RETURNING *
            `;
            
            // Check if we have a result
            if (!result || result.length === 0) {
                throw new Error('Failed to create part version');
            }
            
            return result;
        });
        
        console.log('[createPartVersion] Transaction completed successfully');
        
        // Get the row from the result
        // Standardize on porsager/postgres array-style result format
        // Handle type checking properly to avoid TypeScript errors
        let row = null;
        if (Array.isArray(insertResult)) {
            row = insertResult[0];
        } else if (insertResult && typeof insertResult === 'object' && 'rows' in insertResult) {
            // For ts-postgres style results that have a 'rows' property
            const tsResult = insertResult as { rows: any[] };
            row = tsResult.rows && tsResult.rows.length > 0 ? tsResult.rows[0] : null;
        }
        
        // Process the result
        console.log('[createPartVersion] ✅ SUCCESSFULLY CREATED');
        
        // Handle both possible return formats (ts-postgres and porsager/postgres)
        const getProperty = (propName: string, idx: number) => {
            // Try to access as object property first (porsager style)
            if (typeof row === 'object' && propName in row) {
                return row[propName];
            }
            
            // Fall back to array index (ts-postgres style)
            return Array.isArray(row) ? row[idx] : undefined;
        };
        
        // Include updatedAt and updatedBy to fix PartVersion type requirement
        const result: PartVersion = {
            id: getProperty('id', 0)?.toString() || '',
            partId: getProperty('part_id', 1)?.toString() || '',
            version: getProperty('version', 2)?.toString() || '',
            name: getProperty('name', 3)?.toString() || '',
            status: getProperty('status', 4)?.toString() || '',
            createdBy: getProperty('created_by', 5)?.toString() || '',
            createdAt: getProperty('created_at', 6) ? new Date(getProperty('created_at', 6)) : new Date(),
            shortDescription: getProperty('short_description', 7)?.toString(),
            functionalDescription: getProperty('functional_description', 8)?.toString(),
            longDescription: getProperty('long_description', 9),
            voltageRatingMin: getProperty('voltage_rating_min', 10) ? parseFloat(getProperty('voltage_rating_min', 10)) : undefined,
            voltageRatingMax: getProperty('voltage_rating_max', 11) ? parseFloat(getProperty('voltage_rating_max', 11)) : undefined,
            currentRatingMin: getProperty('current_rating_min', 12) ? parseFloat(getProperty('current_rating_min', 12)) : undefined,
            currentRatingMax: getProperty('current_rating_max', 13) ? parseFloat(getProperty('current_rating_max', 13)) : undefined,
            powerRatingMax: getProperty('power_rating_max', 14) ? parseFloat(getProperty('power_rating_max', 14)) : undefined,
            tolerance: getProperty('tolerance', 15) ? parseFloat(getProperty('tolerance', 15)) : undefined,
            toleranceUnit: getProperty('tolerance_unit', 16)?.toString(),
            electricalProperties: getProperty('electrical_properties', 17),
            dimensions: getProperty('dimensions', 18) ? 
                (typeof getProperty('dimensions', 18) === 'string' ? 
                    JSON.parse(getProperty('dimensions', 18)) : 
                    getProperty('dimensions', 18)) : 
                undefined,
            dimensionsUnit: getProperty('dimensions_unit', 19)?.toString(),
            weight: getProperty('weight', 20) ? parseFloat(getProperty('weight', 20)) : undefined,
            weightUnit: getProperty('weight_unit', 21)?.toString(),
            packageType: getProperty('package_type', 22)?.toString(),
            pinCount: getProperty('pin_count', 23) ? parseInt(getProperty('pin_count', 23), 10) : undefined,
            mechanicalProperties: getProperty('mechanical_properties', 24),
            materialComposition: getProperty('material_composition', 25),
            operatingTemperatureMin: getProperty('operating_temperature_min', 26) ? parseFloat(getProperty('operating_temperature_min', 26)) : undefined,
            operatingTemperatureMax: getProperty('operating_temperature_max', 27) ? parseFloat(getProperty('operating_temperature_max', 27)) : undefined,
            storageTemperatureMin: getProperty('storage_temperature_min', 28) ? parseFloat(getProperty('storage_temperature_min', 28)) : undefined,
            storageTemperatureMax: getProperty('storage_temperature_max', 29) ? parseFloat(getProperty('storage_temperature_max', 29)) : undefined,
            temperatureUnit: getProperty('temperature_unit', 30)?.toString(),
            thermalProperties: getProperty('thermal_properties', 31),
            technicalSpecifications: getProperty('technical_specifications', 32),
            properties: getProperty('properties', 33),
            environmentalData: getProperty('environmental_data', 34),
            revisionNotes: getProperty('revision_notes', 35)?.toString(),
            updatedBy: getProperty('updated_by', 0)?.toString(), // Add missing property
            updatedAt: new Date() // Add missing property with default value
        };
        
        return result;
    } catch (error) {
        console.error('[createPartVersion] Error:', error);
        throw error;
    }
}
