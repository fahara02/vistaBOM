// src/lib/server/parts.ts
import sql from './db/index';
import { randomUUID } from 'crypto';
import { rowToPartVersionCategory,rowToPartAttachment,rowToPartCompliance,rowToPartCustomField,rowToPartVersionTag, rowToPartStructure, rowToPartRepresentation, rowToPartRevision, rowToPartValidation} from '../parts/partUtils';
import type {
  Part,
  PartVersion,
  PartVersionCategory,
  PartStructure,
  PartCompliance,
  PartAttachment,
  PartRepresentation,
  PartRevision,
  PartValidation,
  PartVersionTag,
  PartCustomField
} from './db/types';
import {
  LifecycleStatusEnum,
  ComplianceTypeEnum,
  StructuralRelationTypeEnum,
  PartStatusEnum,
} from './db/types';

/**
 * Safe SQL string literal helper function.
 * Prevents SQL injection when using raw string interpolation.
 * @param str The string to sanitize for SQL
 * @returns A string safe to use in SQL queries
 */
function sanitizeSqlString(str: string): string {
	// Double single quotes for SQL safety
	return str.replace(/'/g, "''");
}

// SQL client is imported directly at the top of the file

/**
 * List all parts with their current version
 */
export async function listParts(): Promise<Array<{ part: Part; currentVersion: PartVersion }>> {
	try {
		console.log('[listParts] Retrieving all parts');
		
		// Using imported sql client directly
		
		// Use SQL template literal syntax for porsager/postgres
		const result = await sql`
		SELECT 
			p.id::TEXT AS id,
			p.creator_id::TEXT AS creator_id,
			p.global_part_number::TEXT AS global_part_number,
			p.status::TEXT AS status,
			p.lifecycle_status::TEXT AS lifecycle_status,
			p.is_public::TEXT AS is_public,
			p.created_at::TEXT AS part_created_at,
			p.updated_by::TEXT AS part_updated_by,
			p.updated_at::TEXT AS part_updated_at,
			p.current_version_id::TEXT AS current_version_id,
			pv.id::TEXT AS version_id,
			pv.part_id::TEXT AS version_part_id,
			pv.version::TEXT AS version,
			pv.name::TEXT AS name,
			pv.short_description::TEXT AS short_description,
			pv.status::TEXT AS version_status,
			pv.created_by::TEXT AS version_created_by,
			pv.created_at::TEXT AS version_created_at,
			pv.updated_by::TEXT AS version_updated_by,
			pv.updated_at::TEXT AS version_updated_at
		FROM "Part" p
		JOIN "PartVersion" pv ON p.current_version_id = pv.id
		ORDER BY p.created_at DESC
		`;

		if (result.length === 0) {
			return [];
		}
		
		// Log raw rows for debugging
		console.log(`[listParts] Found ${result.length} parts\n`);
		
		// Process results - with porsager/postgres, results are returned as objects directly
		const parts = result.map((row: any) => {
			// With porsager/postgres, results are already objects with named properties
			// Ensure we get a valid part ID
			const partId = row.id?.toString(); 
			console.log(`[listParts] Processing part with real ID: '${partId}'`);
			
			if (!partId) {
				console.error('[listParts] Found a row with null part ID');
			}

			const part: Part = {
				id: partId, // This is the actual database ID
				creatorId: row.creator_id?.toString(),
				globalPartNumber: row.global_part_number?.toString() || undefined,
				status: row.status?.toString(),
				lifecycleStatus: row.lifecycle_status?.toString(),
				isPublic: row.is_public === 'true', // Convert string to boolean
				createdAt: row.part_created_at ? new Date(row.part_created_at) : new Date(),
				updatedBy: row.part_updated_by?.toString() || undefined,
				updatedAt: row.part_updated_at ? new Date(row.part_updated_at) : new Date(),
				currentVersionId: row.current_version_id?.toString() || undefined
			};
			
			// Log part object to verify ID is present
			console.log(`[listParts] Created part object with ID: ${part.id}`, JSON.stringify(part, null, 2));

			const currentVersion: PartVersion = {
				id: row.version_id?.toString(),
				partId: row.version_part_id?.toString(),
				version: row.version?.toString(),
				name: row.name?.toString(),
				shortDescription: row.short_description?.toString() || undefined,
				// Map string status to a proper enum value
				status: row.version_status && row.version_status in LifecycleStatusEnum ? 
					row.version_status as LifecycleStatusEnum : 
					LifecycleStatusEnum.DRAFT,
				createdBy: row.version_created_by?.toString(),
				createdAt: row.version_created_at ? new Date(row.version_created_at) : new Date(),
				updatedBy: row.version_updated_by?.toString() || undefined,
				updatedAt: row.version_updated_at ? new Date(row.version_updated_at) : new Date() // Default to current date if undefined
			};
			return { part, currentVersion };
		});
		
		return parts;
	} catch (error) {
		console.error('[listParts] Error retrieving parts:', error);
		return [];
	}
}

/**
 * Get a single part with its current version
 */
export async function getPartWithCurrentVersion(
	partId: string
): Promise<{ part: Part; currentVersion: PartVersion }> {
	try {
		// Stronger validation for partId parameter to avoid database errors
		if (!partId || partId === 'undefined' || partId === 'null' || partId.trim() === '') {
			console.error(`[getPartWithCurrentVersion] Invalid part ID: '${partId}'`);
			throw new Error(`Invalid part ID: cannot be undefined, null, or empty`);
		}

		console.log(`[getPartWithCurrentVersion] Retrieving part with ID: ${partId}`);
		
		// Use SQL template literals for porsager/postgres
		const result = await sql`
		SELECT 
			p.id::TEXT AS id,
			p.creator_id::TEXT AS creator_id,
			p.global_part_number::TEXT AS global_part_number,
			p.status::TEXT AS status,
			p.lifecycle_status::TEXT AS lifecycle_status,
			p.is_public::TEXT AS is_public,
			p.created_at::TEXT AS part_created_at,
			p.updated_by::TEXT AS part_updated_by,
			p.updated_at::TEXT AS part_updated_at,
			p.current_version_id::TEXT AS current_version_id,
			pv.id::TEXT AS version_id,
			pv.part_id::TEXT AS version_part_id,
			pv.version::TEXT AS version,
			pv.name::TEXT AS name,
			pv.short_description::TEXT AS short_description,
			pv.status::TEXT AS version_status,
			pv.created_by::TEXT AS version_created_by,
			pv.created_at::TEXT AS version_created_at,
			pv.updated_by::TEXT AS version_updated_by,
			pv.updated_at::TEXT AS version_updated_at
		FROM "Part" p
		JOIN "PartVersion" pv ON p.current_version_id = pv.id
		WHERE p.id = ${partId}
		`;

		if (result.length === 0) {
			throw new Error(`Part not found with ID: ${partId}`);
		}
		
		// With porsager/postgres, results are objects with named properties
		const row = result[0];
		console.log(`[getPartWithCurrentVersion] Raw result:`, row);

		// Ensure we get a valid part ID
		const partIdStr = row.id?.toString();
		
		if (!partIdStr) {
			console.error('[getPartWithCurrentVersion] Found a row with null part ID');
			throw new Error(`Invalid part ID for query result`);
		}
		if (!partIdStr) {
			console.error('[getPartWithCurrentVersion] Found a part with undefined or null ID!', row);
			throw new Error('Retrieved part has no valid ID');
		}

		const part: Part = {
			id: partIdStr, // This is the actual database ID
			creatorId: row.creator_id?.toString(),
			globalPartNumber: row.global_part_number?.toString() || undefined,
			status: row.status?.toString(),
			lifecycleStatus: row.lifecycle_status?.toString(),
			isPublic: row.is_public === 'true', // Convert string to boolean
			createdAt: row.part_created_at ? new Date(row.part_created_at) : new Date(),
			updatedBy: row.part_updated_by?.toString() || undefined,
			updatedAt: row.part_updated_at ? new Date(row.part_updated_at) : new Date(),
			currentVersionId: row.current_version_id?.toString() || undefined
		};

		// We need to initialize the currentVersion with default values for all fields
		// This ensures all data is properly preserved during edits
		// DEBUG: Check raw version value from database
		const rawVersion = row.version;
		console.log(`[VERSION DEBUG] Raw version from database: type=${typeof rawVersion}, value='${rawVersion}'`)
		
		// FORCE the version to be a string in semantic version format
		let versionString = row.version?.toString() || '0.1.0';
		// If it's a numeric version, convert to semantic version format
		if (!isNaN(Number(versionString)) && !versionString.includes('.')) {
			console.log(`[VERSION DEBUG] Converting numeric version '${versionString}' to semantic format`);
			// Only convert simple numbers, not already formatted versions
			if (versionString === '3') {
				versionString = '0.1.1'; // If it's exactly 3, assume it should be 0.1.1
			} else {
				versionString = `0.0.${versionString}`; // Otherwise use as patch version
			}
		}
		console.log(`[VERSION DEBUG] Final version string: '${versionString}'`);
		
		const currentVersion: PartVersion = {
			id: row.version_id?.toString(),
			partId: row.version_part_id?.toString(),
			version: versionString,
			name: row.name?.toString(),
			shortDescription: row.short_description?.toString() || undefined,
			// Add all other fields with defaults to ensure they're not lost during edits
			functionalDescription: undefined,  // These aren't in the SQL result, but needed for editing
			longDescription: undefined,
			technicalSpecifications: undefined,
			properties: undefined,
			electricalProperties: undefined,
			mechanicalProperties: undefined,
			thermalProperties: undefined,
			materialComposition: undefined,
			environmentalData: undefined,
			revisionNotes: undefined,
			// Physical properties
			weight: undefined,
			weightUnit: undefined,
			dimensions: undefined,
			dimensionsUnit: undefined,
			tolerance: undefined,
			toleranceUnit: undefined,
			packageType: undefined,
			pinCount: undefined,
			// Temperature properties
			operatingTemperatureMin: undefined,
			operatingTemperatureMax: undefined,
			storageTemperatureMin: undefined,
			storageTemperatureMax: undefined,
			temperatureUnit: undefined,
			// Status and metadata
			status: row.version_status && row.version_status in LifecycleStatusEnum ? 
				row.version_status as LifecycleStatusEnum : 
				LifecycleStatusEnum.DRAFT,
			createdBy: row.version_created_by?.toString(),
			createdAt: row.version_created_at ? new Date(row.version_created_at) : new Date(),
			updatedBy: row.version_updated_by?.toString() || undefined,
			updatedAt: row.version_updated_at ? new Date(row.version_updated_at) : new Date() 
		};
		
		// Log that we're adding default values
		console.log(`[getPartWithCurrentVersion] Added default values for all fields not explicitly loaded from database`);
		
		// Log the mapped object for debugging
		console.log(`[getPartWithCurrentVersion] Mapped part object with ID: ${part.id}`)

		return { part, currentVersion };
	} catch (error) {
		console.error(`[getPartWithCurrentVersion] Error retrieving part ${partId}:`, error);
		throw error;
	}
}
export interface CreatePartInput {
    name: string;
    version: string;
    status: LifecycleStatusEnum;
    // Use PartStatusEnum instead of string
    partStatus?: PartStatusEnum;
    shortDescription?: string | null;
    functionalDescription?: string | null;
    // Allow more flexible property types to match form data
    [key: string]: any;
}

/**
 * Create a new part with its initial version
 */
// src/lib/server/parts.ts - Updated createPart function with error logging
export async function createPart(
    input: CreatePartInput,
    userId: string
): Promise<{ part: Part; currentVersion: PartVersion }> {
    const partId = randomUUID();
    const versionId = randomUUID();
    
    // EXTREME DEBUG: Full deep inspection of all values and enums
    console.log('[createPart] ENUM DEBUG - Available values:', Object.values(LifecycleStatusEnum));
    console.log('[createPart] ENUM DEBUG - Checking if input status is valid:', 
        Object.values(LifecycleStatusEnum).includes(input.status));
    
    // Debug the exact value we're getting for status
    console.log('[createPart] Input data:', {
        name: input.name,
        version: input.version,
        status: input.status,
        statusType: typeof input.status,
        statusValue: String(input.status),
        userId: userId,
        partId: partId,
        versionId: versionId
    });
    
    // Ensure status is a string - this handles enum values properly
    const statusValue = String(input.status);
    
    
    // Prepare the lowercase status string
    const statusLower = String(input.status).toLowerCase().replace(/'/g, "''");
    console.log('[createPart] Using status value:', statusLower);
    
    try {
        // Use the partStatus field if provided, otherwise default to CONCEPT
        const partStatusToUse = input.partStatus || PartStatusEnum.CONCEPT;
        console.log('[createPart] Using Part status:', partStatusToUse);
        
        // Proper transaction handling with porsager/postgres using sql.begin
        console.log('[createPart] Starting transaction');
        
        // Begin a transaction using the correct porsager/postgres approach
        const result = await sql.begin(async (transaction) => {
            console.log('[createPart] Inserting part');
            
            // Insert the part record
            await transaction`
            INSERT INTO "Part" (
                id, creator_id, global_part_number, status, lifecycle_status
            ) VALUES (
                ${partId},
                ${userId}, 
                ${input.name}, 
                ${String(partStatusToUse).toLowerCase()}::part_status_enum, 
                ${String(input.status).toLowerCase()}::lifecycle_status_enum
            )
            `;
            console.log('[createPart] Part inserted successfully');
            
            console.log('[createPart] Now inserting PartVersion');
            
            // Insert the part version record
            await transaction`
            INSERT INTO "PartVersion" (
                id, part_id, version, name, status, created_by, updated_by
            ) VALUES (
                ${versionId}, 
                ${partId}, 
                ${input.version}, 
                ${input.name}, 
                ${String(input.status).toLowerCase()}::lifecycle_status_enum, 
                ${userId}, 
                NULL
            )
            `;
            
            console.log('[createPart] PartVersion inserted, now updating Part current_version_id');
            
            // Update the part to reference the new version
            await transaction`
            UPDATE "Part" 
            SET current_version_id = ${versionId} 
            WHERE id = ${partId}
            `;
            console.log('[createPart] Update completed for Part', partId);
            
            // Return value will be the transaction's return and will be committed automatically
            return { partId, versionId };
        });
        
        console.log('[createPart] Transaction committed successfully:', result);
    } catch (error: any) {
        // With sql.begin(), rollback happens automatically on error
        console.error('Database Error in createPart:', error.message, error.stack);
        throw error;
    }

    return getPartWithCurrentVersion(partId);
}

/**
 * Update a part version (select fields)
 */
export async function updatePartVersion(
	data: Partial<PartVersion> & { id: string }
): Promise<void> {
	try {
		// More modern approach with porsager/postgres - build update dynamically
		// Only include fields that are defined in the input data
		let updateFields = [];
		
		if (data.name !== undefined) {
			updateFields.push(`name = ${data.name}`);
		}
		if (data.version !== undefined) {
			updateFields.push(`version = ${data.version}`);
		}
		if (data.status !== undefined) {
			updateFields.push(`status = ${data.status}::text::lifecycle_status_enum`);
		}
		
		// If no fields to update, return early
		if (updateFields.length === 0) {
			console.log('[updatePartVersion] No fields to update');
			return;
		}
		
		// Use sql.unsafe for dynamic SQL with template literals for parameterization
		// This avoids SQL injection while allowing dynamic field updates
		const result = await sql.unsafe(`
			UPDATE "PartVersion" 
			SET ${updateFields.join(', ')} 
			WHERE id = '${data.id}'
			RETURNING id
		`);
		
		console.log(`[updatePartVersion] Updated part version ${data.id}`);
	} catch (error) {
		console.error('[updatePartVersion] Error updating part version:', error);
		throw error;
	}
}

/**
 * Delete a part (cascades to versions)
 */
export async function deletePart(partId: string): Promise<void> {
	try {
		console.log(`[deletePart] Deleting part with ID: ${partId}`);
		
		// Use porsager/postgres transaction handling with sql.begin
		// This handles BEGIN/COMMIT/ROLLBACK automatically
		await sql.begin(async (transaction) => {
			// First lock the part row to prevent concurrent modifications
			// This helps prevent the "tuple concurrently updated" error
			const lockResult = await transaction`
				SELECT id FROM "Part" WHERE id = ${partId} FOR UPDATE
			`;
			
			if (lockResult.length === 0) {
				throw new Error(`Part not found with ID: ${partId}`);
			}
			
			console.log(`[deletePart] Part ${partId} found and locked for deletion`);
			
			// Delete the part (relies on CASCADE for versions)
			const deleteResult = await transaction`
				DELETE FROM "Part" WHERE id = ${partId} RETURNING id
			`;
			
			if (deleteResult.length === 0) {
				throw new Error(`Failed to delete part with ID: ${partId}`);
			}
			
			console.log(`[deletePart] Part ${partId} successfully deleted within transaction`);
			// Transaction automatically commits if no errors
		});
		
		console.log(`[deletePart] Successfully deleted part with ID: ${partId}`);
	} catch (error) {
		console.error(`[deletePart] Error deleting part ${partId}:`, error);
		// With sql.begin(), rollback happens automatically on error
		throw error;
	}
}

// ======================
// Part Version Category
// ======================
export async function addCategoryToPartVersion(partVersionId: string, categoryId: string): Promise<PartVersionCategory> {
    try {
        // Use porsager/postgres template literals for SQL queries
        const result = await sql`
            INSERT INTO "PartVersionCategory" (part_version_id, category_id)
            VALUES (${partVersionId}, ${categoryId}) 
            RETURNING *
        `;
        
        if (result.length === 0) {
            throw new Error(`Failed to add category ${categoryId} to part version ${partVersionId}`);
        }
        
        // With porsager/postgres, results are direct objects
        const row = result[0];
        return rowToPartVersionCategory(row);
    } catch (error) {
        console.error('[addCategoryToPartVersion] Error:', error);
        throw error;
    }
}

export async function removeCategoryFromPartVersion(partVersionId: string, categoryId: string): Promise<void> {
    try {
        // Use template literals for DELETE operation with proper error handling
        await sql`
            DELETE FROM "PartVersionCategory" 
            WHERE part_version_id = ${partVersionId} AND category_id = ${categoryId}
        `;
        
        console.log(`[removeCategoryFromPartVersion] Removed category ${categoryId} from part version ${partVersionId}`);
    } catch (error) {
        console.error('[removeCategoryFromPartVersion] Error:', error);
        throw error;
    }
}

export async function getCategoriesForPartVersion(partVersionId: string): Promise<PartVersionCategory[]> {
    try {
        // Use template literals for SELECT operation with proper error handling
        const result = await sql`
            SELECT * FROM "PartVersionCategory" 
            WHERE part_version_id = ${partVersionId}
        `;
        
        console.log(`[getCategoriesForPartVersion] Found ${result.length} categories for part version ${partVersionId}`);
        
        // Map results using array methods directly on the result
        return result.map(rowToPartVersionCategory);
    } catch (error) {
        console.error('[getCategoriesForPartVersion] Error:', error);
        throw error;
    }
}

/**
 * Update a part record with a new current version ID and status
 * Uses proper transaction handling with row locking to prevent concurrent update issues
 */
export async function updatePartWithStatus(
  partId: string,
  newVersionId: string,
  newStatus: PartStatusEnum
): Promise<void> {
  console.log(`[updatePartWithStatus] Updating part ${partId} with new version ${newVersionId} and status ${newStatus}`);
  
  // Get SQL client
  // Using the sql client imported at the top of the file
  
  try {
    // Begin transaction - with porsager/postgres, transactions are handled with sql.begin()
    await sql.begin(async (txSql: typeof sql) => {
      console.log('[updatePartWithStatus] Transaction started');
      
      // First, lock the part row to prevent concurrent modifications
      // This is critical to avoid the "tuple concurrently updated" error
      const lockResult = await txSql`
        SELECT id FROM "Part" WHERE id = ${partId} FOR UPDATE
      `;
      
      if (lockResult.length === 0) {
        throw new Error(`Part with ID ${partId} not found or could not be locked`);
      }
      
      console.log('[updatePartWithStatus] Part row locked for update');
      
      // Now update the part with the new version ID and status
      const updateResult = await txSql`
        UPDATE "Part"
        SET 
          current_version_id = ${newVersionId},
          status = ${newStatus}::TEXT::part_status_enum,
          updated_at = NOW()
        WHERE id = ${partId}
        RETURNING id
      `;
      
      if (updateResult.length === 0) {
        throw new Error(`Failed to update part ${partId}`);
      }
      
      console.log('[updatePartWithStatus] Part updated successfully');
      // Transaction automatically commits if no errors
    });
    
    console.log('[updatePartWithStatus] Transaction committed');
  } catch (error) {
    // Transaction automatically rolls back on error
    console.error('[updatePartWithStatus] Transaction rolled back due to error:', error);
    throw error;
  }
}

/**
 * Create a new version of a part
 */
export async function createPartVersion(partVersion: Partial<PartVersion> & {
    id: string;
    partId: string;
    version: string;
    name: string;
    status: string;
    createdBy: string;
}): Promise<PartVersion> {
    try {
        // SUPER DETAILED LOGGING FOR DEBUG
        console.log('[createPartVersion] 🚨🚨🚨 ATTEMPTING TO CREATE VERSION');
        console.log('[createPartVersion] 🚨 REQUIRED FIELDS CHECK:');
        console.log(`  - id provided: ${!!partVersion.id} (${partVersion.id})`);
        console.log(`  - partId provided: ${!!partVersion.partId} (${partVersion.partId})`);
        console.log(`  - name provided: ${!!partVersion.name} (${partVersion.name})`);
        console.log(`  - version provided: ${!!partVersion.version} (${partVersion.version})`);
        console.log(`  - status provided: ${!!partVersion.status} (${partVersion.status})`);
        console.log(`  - createdBy provided: ${!!partVersion.createdBy} (${partVersion.createdBy})`);
        
        // Detailed logging to see ALL properties - NO CHERRY PICKING
        console.log('[createPartVersion] 100% COMPLETE INCOMING DATA:', JSON.stringify(partVersion, null, 2));
        
        // Get the database client
        // Using the sql client imported at the top of the file
        
        // Extra validation to catch common failures
        if (!partVersion.name || !partVersion.version || !partVersion.status) {
            console.error('[createPartVersion] ❌ CRITICAL ERROR - MISSING REQUIRED FIELDS');
            const errorDetails = {
                name: partVersion.name ? 'OK' : 'MISSING',
                version: partVersion.version ? 'OK' : 'MISSING',
                status: partVersion.status ? 'OK' : 'MISSING'
            };
            console.error('[createPartVersion] ❌ MISSING FIELD DETAILS:', errorDetails);
        }
                
        // Create the insert query as text
        const insertQuery = `
            INSERT INTO "PartVersion" (
                id, part_id, version, name, status, created_by, created_at,
                short_description, functional_description, long_description,
                voltage_rating_min, voltage_rating_max, current_rating_min, current_rating_max,
                power_rating_max, tolerance, tolerance_unit, electrical_properties,
                dimensions, dimensions_unit, weight, weight_unit, package_type, pin_count,
                mechanical_properties, material_composition,
                operating_temperature_min, operating_temperature_max,
                storage_temperature_min, storage_temperature_max, temperature_unit, thermal_properties,
                technical_specifications, properties, environmental_data, revision_notes
            ) VALUES (
                $1, $2, $3, $4, $5::TEXT::lifecycle_status_enum, $6, NOW(),
                $7, $8, $9::JSONB, 
                $10::NUMERIC, $11::NUMERIC, $12::NUMERIC, $13::NUMERIC,
                $14::NUMERIC, $15::NUMERIC, 
                $16, $17::JSONB, 
                $18::JSONB, $19, $20::NUMERIC, $21, $22, $23::INTEGER,
                $24::JSONB, $25::JSONB,
                $26::NUMERIC, $27::NUMERIC, $28::NUMERIC, $29::NUMERIC, 
                $30, $31::JSONB,
                $32::JSONB, $33::JSONB, $34::JSONB, $35
            ) RETURNING *
        `;
        
        // Make sure all JSON objects are properly stringified
        const longDescription = partVersion.longDescription 
            ? JSON.stringify(partVersion.longDescription) 
            : null;
            
        const electricalProperties = partVersion.electricalProperties 
            ? JSON.stringify(partVersion.electricalProperties) 
            : null;
            
        const dimensions = partVersion.dimensions 
            ? JSON.stringify(partVersion.dimensions) 
            : null;
            
        const mechanicalProperties = partVersion.mechanicalProperties 
            ? JSON.stringify(partVersion.mechanicalProperties) 
            : null;
            
        const materialComposition = partVersion.materialComposition 
            ? JSON.stringify(partVersion.materialComposition) 
            : null;
            
        const thermalProperties = partVersion.thermalProperties 
            ? JSON.stringify(partVersion.thermalProperties) 
            : null;
            
        const technicalSpecifications = partVersion.technicalSpecifications 
            ? JSON.stringify(partVersion.technicalSpecifications) 
            : null;
            
        const properties = partVersion.properties 
            ? JSON.stringify(partVersion.properties) 
            : null;
            
        const environmentalData = partVersion.environmentalData 
            ? JSON.stringify(partVersion.environmentalData) 
            : null;
        
        // Prepare params array
        const params = [
            partVersion.id,
            partVersion.partId,
            partVersion.version,
            partVersion.name,
            partVersion.status,
            partVersion.createdBy,
            partVersion.shortDescription,
            partVersion.functionalDescription,
            longDescription,  // Properly stringified
            partVersion.voltageRatingMin === null ? null : String(partVersion.voltageRatingMin),
            partVersion.voltageRatingMax === null ? null : String(partVersion.voltageRatingMax),
            partVersion.currentRatingMin === null ? null : String(partVersion.currentRatingMin),
            partVersion.currentRatingMax === null ? null : String(partVersion.currentRatingMax),
            partVersion.powerRatingMax === null ? null : String(partVersion.powerRatingMax),
            partVersion.tolerance === null ? null : String(partVersion.tolerance),
            partVersion.toleranceUnit,
            electricalProperties,  // Properly stringified
            dimensions,  // Properly stringified
            partVersion.dimensionsUnit,
            partVersion.weight === null ? null : String(partVersion.weight),
            partVersion.weightUnit,
            partVersion.packageType,
            partVersion.pinCount === null ? null : String(partVersion.pinCount),
            mechanicalProperties,  // Properly stringified
            materialComposition,  // Properly stringified
            partVersion.operatingTemperatureMin === null ? null : String(partVersion.operatingTemperatureMin),
            partVersion.operatingTemperatureMax === null ? null : String(partVersion.operatingTemperatureMax),
            partVersion.storageTemperatureMin === null ? null : String(partVersion.storageTemperatureMin),
            partVersion.storageTemperatureMax === null ? null : String(partVersion.storageTemperatureMax),
            partVersion.temperatureUnit,
            thermalProperties,  // Properly stringified
            technicalSpecifications,  // Properly stringified
            properties,  // Properly stringified
            environmentalData,  // Properly stringified
            partVersion.revisionNotes
        ];
        
        console.log('[createPartVersion] 💥 COMPLETE RAW PARAMETERS:', JSON.stringify(params, null, 2));
        
        // With porsager/postgres, use sql.begin for proper transaction handling to prevent concurrent update issues
        const insertResult = await sql.begin(async (transaction) => {
            // First, lock the parent part to prevent concurrent modifications
            // This helps prevent the "tuple concurrently updated" error
            const lockResult = await transaction`
                SELECT id FROM "Part" WHERE id = ${partVersion.partId} FOR UPDATE
            `;
            
            if (lockResult.length === 0) {
                throw new Error(`Part with ID ${partVersion.partId} not found or could not be locked`);
            }
            
            console.log('[createPartVersion] Part row locked for update');
            
            // Use the unsafe method for dynamic queries, but within the transaction
            // This gives us both dynamic SQL capability and transaction safety
            const result = await transaction.unsafe(insertQuery, params.filter(p => p !== undefined));
            
            // Check if we have a result
            if (!result || result.length === 0) {
                throw new Error('Failed to create part version');
            }
            
            return result;
        });
        
        console.log('[createPartVersion] Transaction completed successfully');
        
        // Get the row from the result
        // Standardize on porsager/postgres array-style result format
        // Handle type checking properly to avoid TypeScript errors
        let row = null;
        if (Array.isArray(insertResult)) {
            row = insertResult[0];
        } else if (insertResult && typeof insertResult === 'object' && 'rows' in insertResult) {
            // For ts-postgres style results that have a 'rows' property
            const tsResult = insertResult as { rows: any[] };
            row = tsResult.rows && tsResult.rows.length > 0 ? tsResult.rows[0] : null;
        }
        
        // Process the result
        console.log('[createPartVersion] ✅ SUCCESSFULLY CREATED');
        
        // Handle both possible return formats (ts-postgres and porsager/postgres)
        const getProperty = (propName: string, idx: number) => {
            // Try to access as object property first (porsager style)
            if (typeof row === 'object' && propName in row) {
                return row[propName];
            }
            
            // Fall back to array index (ts-postgres style)
            return Array.isArray(row) ? row[idx] : undefined;
        };
        
        // Include updatedAt and updatedBy to fix PartVersion type requirement
        const result: PartVersion = {
            id: getProperty('id', 0)?.toString() || '',
            partId: getProperty('part_id', 1)?.toString() || '',
            version: getProperty('version', 2)?.toString() || '',
            name: getProperty('name', 3)?.toString() || '',
            status: getProperty('status', 4)?.toString() || '',
            createdBy: getProperty('created_by', 5)?.toString() || '',
            createdAt: getProperty('created_at', 6) ? new Date(getProperty('created_at', 6)) : new Date(),
            shortDescription: getProperty('short_description', 7)?.toString(),
            functionalDescription: getProperty('functional_description', 8)?.toString(),
            longDescription: getProperty('long_description', 9),
            voltageRatingMin: getProperty('voltage_rating_min', 10) ? parseFloat(getProperty('voltage_rating_min', 10)) : undefined,
            voltageRatingMax: getProperty('voltage_rating_max', 11) ? parseFloat(getProperty('voltage_rating_max', 11)) : undefined,
            currentRatingMin: getProperty('current_rating_min', 12) ? parseFloat(getProperty('current_rating_min', 12)) : undefined,
            currentRatingMax: getProperty('current_rating_max', 13) ? parseFloat(getProperty('current_rating_max', 13)) : undefined,
            powerRatingMax: getProperty('power_rating_max', 14) ? parseFloat(getProperty('power_rating_max', 14)) : undefined,
            tolerance: getProperty('tolerance', 15) ? parseFloat(getProperty('tolerance', 15)) : undefined,
            toleranceUnit: getProperty('tolerance_unit', 16)?.toString(),
            electricalProperties: getProperty('electrical_properties', 17),
            dimensions: getProperty('dimensions', 18) ? 
                (typeof getProperty('dimensions', 18) === 'string' ? 
                    JSON.parse(getProperty('dimensions', 18)) : 
                    getProperty('dimensions', 18)) : 
                undefined,
            dimensionsUnit: getProperty('dimensions_unit', 19)?.toString(),
            weight: getProperty('weight', 20) ? parseFloat(getProperty('weight', 20)) : undefined,
            weightUnit: getProperty('weight_unit', 21)?.toString(),
            packageType: getProperty('package_type', 22)?.toString(),
            pinCount: getProperty('pin_count', 23) ? parseInt(getProperty('pin_count', 23), 10) : undefined,
            mechanicalProperties: getProperty('mechanical_properties', 24),
            materialComposition: getProperty('material_composition', 25),
            operatingTemperatureMin: getProperty('operating_temperature_min', 26) ? parseFloat(getProperty('operating_temperature_min', 26)) : undefined,
            operatingTemperatureMax: getProperty('operating_temperature_max', 27) ? parseFloat(getProperty('operating_temperature_max', 27)) : undefined,
            storageTemperatureMin: getProperty('storage_temperature_min', 28) ? parseFloat(getProperty('storage_temperature_min', 28)) : undefined,
            storageTemperatureMax: getProperty('storage_temperature_max', 29) ? parseFloat(getProperty('storage_temperature_max', 29)) : undefined,
            temperatureUnit: getProperty('temperature_unit', 30)?.toString(),
            thermalProperties: getProperty('thermal_properties', 31),
            technicalSpecifications: getProperty('technical_specifications', 32),
            properties: getProperty('properties', 33),
            environmentalData: getProperty('environmental_data', 34),
            revisionNotes: getProperty('revision_notes', 35)?.toString(),
            updatedBy: getProperty('updated_by', 0)?.toString(), // Add missing property
            updatedAt: new Date() // Add missing property with default value
        };
        
        return result;
    } catch (error) {
        console.error('[createPartVersion] Error:', error);
        throw error;
    }
}
