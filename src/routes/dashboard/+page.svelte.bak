<script lang="ts">
	// Import type definitions
	import type { Category } from '$lib/types/schemaTypes';
	import type { PageData } from './$types';

	// Import components and utilities
	import { goto, invalidate, invalidateAll } from '$app/navigation';
	import { browser } from '$app/environment';
	import { PartForm } from '$lib/components/forms';
	import CategoryComboBox from '$lib/components/forms/CategoryComboBox.svelte';
	import CategoryComponent from '$lib/components/cards/category.svelte';
	import ManufacturersTab from '$lib/components/dashboard/manufacturers-tab.svelte';
	import SuppliersTab from '$lib/components/dashboard/suppliers-tab.svelte';
	import { categoryFormSchema } from '$lib/schema/schema';
	import { z } from 'zod';
	import { superForm, type SuperForm } from 'sveltekit-superforms/client';
	import { enhance } from '$app/forms';
	import { LifecycleStatusEnum, PartStatusEnum } from '$lib/types/enums';

	// Type definitions for form data
	type CategoryFormType = z.infer<typeof categoryFormSchema>;
	// Import form types from formTypes.ts
	import type { SupplierFormData, ManufacturerFormData, DashboardManufacturer, DashboardSupplier } from '$lib/types/formTypes';



	export let data: PageData;
	const user = data.user!;

	// Ensure fullName is a string for rendering
	const fullName = user.username || user.email || '';
	const initial = fullName.charAt(0) || '';
	
	// Variables for handling data based on the structure returned from the server
	let categories: Category[] = data?.categories || [];
	// For backward compatibility, alias categories as allCategories 
	let allCategories: Category[] = categories;
	// Extract projects data from page data
	const projects = data?.projects || [];
	// Define typed user items - use proper types instead of any
	let userParts = data?.userParts || [];
	
	/**
	 * Transform manufacturer data from server format (with snake_case property names)
	 * to the DashboardManufacturer interface format needed for our UI
	 * Ensuring proper handling of null values to match expected component types
	 */
	function transformManufacturerData(manufacturers: any[]): DashboardManufacturer[] {
		// Log the first raw manufacturer data to debug structure
		if (manufacturers.length > 0) {
			console.log('Raw manufacturer data from server:', manufacturers[0]);
		}
		
		// Create a Set to track used IDs and avoid duplicates
		const usedIds = new Set<string>();
		
		return manufacturers.map(manufacturer => {
			// The server returns fields in camelCase but our component expects snake_case
			// Handle the camelCase to snake_case conversion for IDs
			let manufacturerId = manufacturer.manufacturerId || manufacturer.manufacturer_id || '';
			
			// Ensure we have a valid ID - generate UUID if missing
			if (!manufacturerId) {
				manufacturerId = crypto.randomUUID();
			}
			
			// Check for duplicate IDs and generate a new one if needed
			if (usedIds.has(manufacturerId)) {
				manufacturerId = crypto.randomUUID();
			}
			usedIds.add(manufacturerId);
			
			// Convert server data to our DashboardManufacturer interface with consistent snake_case properties
			const transformedManufacturer: DashboardManufacturer = {
				manufacturer_id: manufacturerId,
				manufacturer_name: manufacturer.name || manufacturer.manufacturer_name || '',
				// Convert null to undefined to match expected type in components
				manufacturer_description: manufacturer.description === null ? undefined : (manufacturer.description || manufacturer.manufacturer_description),
				website_url: manufacturer.website === null ? undefined : (manufacturer.website || manufacturer.website_url),
				logo_url: manufacturer.logoUrl === null ? undefined : (manufacturer.logoUrl || manufacturer.logo_url),
				contact_info: manufacturer.contact_info === null ? undefined : manufacturer.contact_info,
				custom_fields: manufacturer.custom_fields,
				created_at: new Date(manufacturer.createdAt || manufacturer.created_at || Date.now()),
				updated_at: manufacturer.updatedAt ? new Date(manufacturer.updatedAt) 
						 : (manufacturer.updated_at ? new Date(manufacturer.updated_at) : new Date()), // Ensure it's always a Date
				created_by: manufacturer.createdBy || manufacturer.created_by || user?.user_id || '',
				updated_by: manufacturer.updatedBy === null ? undefined : (manufacturer.updatedBy || manufacturer.updated_by)
			};
			return transformedManufacturer;
		});
	}

	/**
	 * Transform supplier data from server format to the DashboardSupplier interface
	 * Ensuring proper handling of null values and consistent data types
	 */
	function transformSupplierData(suppliers: any[]): DashboardSupplier[] {
		if (suppliers.length > 0) {
			console.log('Raw supplier data from server:', suppliers[0]);
		}
		
		// Create a Set to track used IDs and avoid duplicates
		const usedIds = new Set<string>();
		
		return suppliers.map(supplier => {
			// Handle ID field which might be in different formats
			let supplierId = supplier.supplierId || supplier.supplier_id || '';
			
			// Ensure we have a valid ID
			if (!supplierId) {
				supplierId = crypto.randomUUID();
			}
			
			// Check for duplicate IDs
			if (usedIds.has(supplierId)) {
				supplierId = crypto.randomUUID();
			}
			usedIds.add(supplierId);
			
			// Process contact_info to ensure it's a string or null
			let contactInfo: string | null = null;
			if (supplier.contact_info !== null && supplier.contact_info !== undefined) {
				if (typeof supplier.contact_info === 'string') {
					contactInfo = supplier.contact_info;
				} else if (typeof supplier.contact_info === 'object') {
					// Convert object to JSON string
					try {
						contactInfo = JSON.stringify(supplier.contact_info);
					} catch (e) {
						console.error('Error stringifying contact_info:', e);
						contactInfo = '{}';
					}
				}
			}
			
			// Process custom_fields to ensure it's a Record<string, unknown> or null
			let customFields: Record<string, unknown> | null = null;
			if (supplier.custom_fields !== null && supplier.custom_fields !== undefined) {
				if (typeof supplier.custom_fields === 'string') {
					try {
						customFields = JSON.parse(supplier.custom_fields);
					} catch (e) {
						console.error('Error parsing custom_fields string:', e);
						customFields = {};
					}
				} else if (typeof supplier.custom_fields === 'object') {
					customFields = supplier.custom_fields;
				}
			}
			
			// Transform to match the DashboardSupplier interface
			const transformedSupplier: DashboardSupplier = {
				supplier_id: supplierId,
				supplier_name: supplier.name || supplier.supplier_name || '',
				supplier_description: supplier.description === null ? undefined : (supplier.description || supplier.supplier_description),
				website_url: supplier.website === null ? undefined : (supplier.website || supplier.website_url),
				logo_url: supplier.logoUrl === null ? undefined : (supplier.logoUrl || supplier.logo_url),
				contact_info: contactInfo,
				custom_fields: customFields,
				created_at: new Date(supplier.createdAt || supplier.created_at || Date.now()),
				updated_at: supplier.updatedAt ? new Date(supplier.updatedAt) 
						 : (supplier.updated_at ? new Date(supplier.updated_at) : new Date()),
				created_by: supplier.createdBy || supplier.created_by || user?.user_id || '',
				updated_by: supplier.updatedBy === null ? undefined : (supplier.updatedBy || supplier.updated_by)
			};
			return transformedSupplier;
		});
	}

	// Transform the raw manufacturer data to match our DashboardManufacturer interface
	let userManufacturers: DashboardManufacturer[] = transformManufacturerData(data?.userManufacturers || []);
	// Transform supplier data to match our DashboardSupplier interface
	let userSuppliers: DashboardSupplier[] = transformSupplierData(data?.userSuppliers || []);
	
	// Transform server-side camelCase userCategories to component's snake_case format
	$: transformedCategories = transformCategoryData(data?.userCategories || []);

	// Reference to form element
	let partFormElement: HTMLFormElement;
	
	// Initialize forms using superForm
	const { form: categoryForm, errors: categoryErrors, enhance: categoryEnhance, submitting: categorySubmitting, message: categoryMessage } = superForm(data.forms?.category, {
		dataType: 'json',
		onResult: ({ result }) => {
			if (result.type === 'success') {
				showCategoryForm = false;
				editCategoryMode = false;
				currentCategoryId = null;
				refreshData();
			}
			return result;
		}
	});
	
	const { form: partForm, errors: partErrors, enhance: partEnhance, submitting: partSubmitting, message: partMessage } = superForm(data.forms?.part, {
		dataType: 'json'
	});
	
	const { form: manufacturerForm, errors: manufacturerErrors, enhance: manufacturerEnhance, submitting: manufacturerSubmitting, message: manufacturerMessage } = superForm(data.forms?.manufacturer || {
			manufacturer_id: '',
			manufacturer_name: '',
			manufacturer_description: '',
			website_url: '',
			logo_url: '',
			contact_info: '{}',
			custom_fields: '{}',
			created_by: user.user_id,
			updated_by: user.user_id
		}, {
		dataType: 'json',
		resetForm: true,
		// Properly handle form validation before submission
		validationMethod: 'submit-only',
		onSubmit: ({ formData, cancel }) => {
			// Log the submission data for debugging
			console.log('Submitting manufacturer form with data:', Object.fromEntries(formData.entries()));
			
			// Ensure manufacturer_name is present
			if (!formData.get('manufacturer_name') || String(formData.get('manufacturer_name')).trim() === '') {
				cancel();
				return {
					manufacturer_name: ['Manufacturer name is required']
				};
			}
		},
		onResult: ({ result }) => {
			console.log('Manufacturer form submission result:', result);
			
			// Handle the result of form submission
			if (result.type === 'success') {
				// Close the form and reset edit mode
				showManufacturerForm = false;
				editManufacturerMode = false;
				currentManufacturerId = null;
				
				// Refresh the data to show the new/updated manufacturer
				refreshData();
			} else if (result.type === 'error') {
				console.error('Manufacturer form submission error:', result.error);
			}
			return result;
		}
	});
	
	// Function to directly set form values to bypass store subscription issues
	function updateManufacturerForm(formData: any) {
		console.log('Updating manufacturer form with data:', formData);
		
		// Create a complete form object first to ensure all fields are properly set
		const updatedForm = {
			// Required fields
			manufacturer_id: formData.manufacturer_id || '',
			manufacturer_name: formData.manufacturer_name || '',
			
			// Optional fields with proper type handling
			manufacturer_description: formData.manufacturer_description || '',
			website_url: formData.website_url || '',
			logo_url: formData.logo_url || '',
			
			// JSON fields with proper format handling
			contact_info: processJsonField(formData.contact_info),
			custom_fields: processJsonField(formData.custom_fields),
			
			// User tracking fields
			created_by: formData.created_by || user.user_id,
			updated_by: user.user_id, // Always set to current user for updates
			
			// Add timestamp fields to satisfy TypeScript
			created_at: formData.created_at || new Date(),
			updated_at: formData.updated_at || new Date()
		};
		
		// Update the form with the complete object
		$manufacturerForm = updatedForm;
		
		console.log('Updated manufacturer form:', $manufacturerForm);
	}
	
	// Helper function to process JSON fields consistently
	function processJsonField(value: any): string {
		if (!value) return '{}';
		
		// If it's already a string, check if it's valid JSON
		if (typeof value === 'string') {
			if (value.trim() === '') return '{}';
			
			try {
				// Try to parse and re-stringify to ensure valid JSON format
				const parsed = JSON.parse(value);
				return JSON.stringify(parsed);
			} catch (e) {
				// If it's not valid JSON but looks like it might be key-value pairs
				if (value.includes(':') && !value.startsWith('{')) {
					try {
						// Try to convert key-value format to JSON
						const pairs = value.split(/[;\n]+/);
						const obj: Record<string, string> = {};
						
						for (const pair of pairs) {
							const [key, val] = pair.split(':').map(s => s.trim());
							if (key && val) {
								obj[key] = val;
							}
						}
						return JSON.stringify(obj);
					} catch {
						// If conversion fails, store as notes
						return JSON.stringify({ notes: value });
					}
				} else {
					// If not in key-value format, store as notes
					return JSON.stringify({ notes: value });
				}
			}
		}
		
		// If it's an object, stringify it
		if (typeof value === 'object') {
			return JSON.stringify(value);
		}
		
		// For other types, convert to string and wrap in JSON
		return JSON.stringify({ value: String(value) });
	}
	
	const { form: supplierForm, errors: supplierErrors, enhance: supplierEnhance, submitting: supplierSubmitting, message: supplierMessage } = superForm(data.forms?.supplier, {
		dataType: 'json',
		resetForm: true,
		// Handle form data before submission to ensure conformity with schema
		onSubmit: ({ formData }) => {
			// Generate a valid UUID for supplier_id if empty or missing
			const supplierIdValue = formData.get('supplier_id');
			if (!supplierIdValue || supplierIdValue === '') {
				const uuid = crypto.randomUUID();
				formData.set('supplier_id', uuid);
				// Also update the reactive store
				$supplierForm.supplier_id = uuid;
			}

			// Handle contact info field - ensure it's properly formatted as JSON
			const contactInfo = formData.get('contact_info');
			if (contactInfo && typeof contactInfo === 'string' && contactInfo.trim() !== '') {
				try {
					// Try to parse it as JSON to validate it
					JSON.parse(contactInfo);
					// It's valid JSON, so we'll keep it as is
				} catch (e) {
					// Not valid JSON, so we'll wrap it as a note
					formData.set('contact_info', JSON.stringify({ notes: contactInfo }));
				}
			} else if (contactInfo === '') {
				// Empty string should be null for schema compliance
				// Can't use undefined with FormData.set()
				formData.set('contact_info', '');
			}

			// No need to process empty fields anymore - we just leave them as empty strings
			// and let the server handle the conversion to null where appropriate
			// The server's processEmptyString function will properly convert these
		},
		onResult: ({ result }) => {
			if (result.type === 'success') {
				showSupplierForm = false;
				refreshData();
			}
			return result;
		}
	});
	
	// Variables for edit mode tracking
	let editCategoryMode = false;
	let currentCategoryId: string | null = null;
	
	// Manufacturer edit mode tracking
	let editManufacturerMode = false;
	let currentManufacturerId: string | null = null;
	
	// Supplier edit mode tracking
	let editSupplierMode = false;
	let currentSupplierId: string | null = null;

	// Tab management with localStorage persistence
	type TabType = 'projects' | 'parts' | 'manufacturers' | 'suppliers' | 'categories';
	
	// Initialize activeTab from localStorage if available, otherwise default to 'projects'
	let activeTab: TabType = 'projects';
	
	// Only access localStorage in browser environment
	if (typeof window !== 'undefined') {
		const storedTab = localStorage.getItem('vistaBOM_activeTab');
		if (storedTab && ['projects', 'parts', 'manufacturers', 'suppliers', 'categories'].includes(storedTab)) {
			activeTab = storedTab as TabType;
		}
	}
	
	// Function to set active tab and save to localStorage
	function setActiveTab(tab: TabType): void {
		activeTab = tab;
		if (typeof window !== 'undefined') {
			localStorage.setItem('vistaBOM_activeTab', tab);
		}
	}

	// Form visibility toggles
	let showPartForm = false;
	let showManufacturerForm = false;
	let showCategoryForm = false;
	let showSupplierForm = false;


	
	// Data refresh function to handle updates without page reload
	async function refreshData() {
		try {
			// Store current tab
			const currentTab = activeTab;
			
			// Use SvelteKit's invalidate to refresh the data rather than direct fetch
			// This ensures the data is loaded through the proper +page.server.ts load function
			
			// Add a small delay to prevent UI jank during invalidation
			await Promise.all([
				invalidate('data:dashboard'),
				new Promise(resolve => setTimeout(resolve, 200))
			]);
			
			// The data is now updated automatically by SvelteKit's reactivity
			// Update local variables from the refreshed data object
			categories = data.categories || [];
			allCategories = data.categories || []; // Keep the alias updated
			transformedCategories = transformCategoryData(data.userCategories || []);
			userParts = data.userParts || [];
			// Apply transformation to manufacturer data to maintain type consistency
			userManufacturers = transformManufacturerData(data.userManufacturers || []);
			userSuppliers = transformSupplierData(data.userSuppliers || []);
			
			// Restore tab state from localStorage or use current tab as fallback
			if (typeof window !== 'undefined') {
				activeTab = (localStorage.getItem('vistaBOM_activeTab') as TabType) || currentTab;
			} else {
				activeTab = currentTab;
			}
			console.log('Dashboard data refresh complete.');
		} catch (error) {
			console.error('Error refreshing dashboard data:', error);
		}
	}
	
	// For backward compatibility - can be replaced with refreshData() in the future
	async function refreshCategoryData() {
		await refreshData();
	}

	/**
	 * Helper function to transform categories from server's camelCase format to snake_case
	 * The server returns objects with camelCase properties but we need snake_case for our components
	 */
	function transformCategoryData(categories: any[]): (Category & { parent_name?: string | undefined })[] {
		return categories.map(category => {
			// Create properly typed Category object from the camelCase data
			const transformedCategory: Category & { parent_name?: string | undefined } = {
				category_id: category.categoryId || '',
				category_name: category.categoryName || '',
				category_description: category.categoryDescription || null,
				category_path: category.categoryPath || '',
				parent_id: category.parentId || null,
				is_public: Boolean(category.isPublic),
				created_at: category.createdAt ? new Date(category.createdAt) : new Date(), 
				updated_at: category.updatedAt ? new Date(category.updatedAt) : new Date(),
				created_by: category.createdBy || '',
				updated_by: category.updatedBy || null,
				is_deleted: false, // We know this is false because the server filters deleted categories
				deleted_at: null,
				deleted_by: null,
				parent_name: category.parentName || undefined // Add parent_name from the join, ensure it's string or undefined
			};
			return transformedCategory;
		});
	}

	// Function to toggle supplier form visibility
	function toggleSupplierForm() {
		showSupplierForm = !showSupplierForm;
		
		// Reset form to initial values when opening
		if (showSupplierForm) {
			// CRITICAL: Force complete form reset first, don't rely on previous state
			// This resets all fields including any persisted values in the form state
			const emptyForm = {
				supplier_id: '', // ALWAYS empty for new suppliers
				supplier_name: '',
				supplier_description: '',
				website_url: '',
				contact_info: '',
				logo_url: '',
				created_at: new Date(),
				updated_at: new Date(),
				custom_fields: {},
				created_by: '',
				updated_by: ''
			};
			
			// Apply the complete reset by assigning the entire object
			$supplierForm = emptyForm;
			console.log('RESET: New supplier form with EMPTY supplier_id:', $supplierForm.supplier_id);
			
			// Force a DOM refresh to ensure the form is truly reset
			setTimeout(() => {
				// Double-check that supplier_id is still empty after reset
				if ($supplierForm.supplier_id) {
					console.warn('WARNING: supplier_id was not empty after reset, forcing empty again');
					$supplierForm.supplier_id = '';
				}
			}, 0);
		}
	}
	
	// Event handlers for entity deletion
	function handleCategoryDeleted(event: CustomEvent<{ categoryId: string }>) {
		transformedCategories = transformedCategories.filter(cat => cat.category_id !== event.detail.categoryId);
		refreshData();
	}
	
	// Function to cancel category edit mode
	function cancelCategoryEdit() {
		editCategoryMode = false;
		currentCategoryId = null;
		$categoryForm = {
			category_name: '',
			category_description: '',
			parent_id: null, // Using null instead of undefined to satisfy TypeScript string | null type
			is_public: true
		};
	}
	
	// Function to toggle part form visibility
	function togglePartForm() {
		showPartForm = !showPartForm;
	}
	
	// Function to handle supplier deletion event
	function handleSupplierDeleted(event: CustomEvent<{ supplierId: string }>) {
		console.log('Supplier deleted:', event.detail.supplierId);
		refreshData();
	}

	// Function to handle manufacturer edit
	function editManufacturer(manufacturer: DashboardManufacturer) {
		console.log('Editing manufacturer:', manufacturer);
		
		// Set edit mode
		editManufacturerMode = true;
		currentManufacturerId = manufacturer.manufacturer_id;
		showManufacturerForm = true;
		
		// Make sure we have all required fields, starting with current form structure
		const currentForm = { ...$manufacturerForm };
		
		// Create a properly formatted form data object with all required fields
		// Map from dashboard data format to form format
		$manufacturerForm = {
			...currentForm,
			manufacturer_id: manufacturer.manufacturer_id,
			manufacturer_name: manufacturer.manufacturer_name,
			manufacturer_description: manufacturer.manufacturer_description || '',
			website_url: manufacturer.website_url || '',
			// Correctly handle contact_info based on its type
			contact_info: typeof manufacturer.contact_info === 'string'
				? manufacturer.contact_info
				: manufacturer.contact_info
					? JSON.stringify(manufacturer.contact_info)
					: '',
			logo_url: manufacturer.logo_url || '',
			// Ensure custom_fields is properly formatted
			custom_fields: typeof manufacturer.custom_fields === 'string'
				? JSON.parse(manufacturer.custom_fields || '{}')
				: manufacturer.custom_fields || {}
		};
		
		console.log('Form data set to:', $manufacturerForm);
		
		// Scroll to the form
		setTimeout(() => {
			const formContainer = document.querySelector('.form-container');
			if (formContainer) {
				console.log('Scrolling to form container');
				formContainer.scrollIntoView({ behavior: 'smooth' });
			} else {
				console.warn('Form container not found for scrolling');
			}
		}, 100);
	}
	
	// Function to cancel manufacturer edit mode
	function cancelManufacturerEdit() {
		editManufacturerMode = false;
		currentManufacturerId = null;
		showManufacturerForm = false;
		
		// Reset form data - need to keep the base structure from SuperForm
		const currentForm = { ...$manufacturerForm };
		// Only reset the editable fields
		$manufacturerForm = {
			...currentForm,
			manufacturer_id: '',
			manufacturer_name: '',
			manufacturer_description: '',
			website_url: '',
			contact_info: '',
			logo_url: '',
			custom_fields: {}
		};
	}
	
	// Function to handle category edit event
	function handleCategoryEdit(event: CustomEvent<{ category: Category }>) {
		const categoryToEdit = event.detail.category;
		console.log('Editing category:', categoryToEdit);
		
		// Set edit mode and current category ID
		editCategoryMode = true;
		currentCategoryId = categoryToEdit.category_id;
		
		// Set form data using standard CategoryFormType from schema.ts
		// The schema now includes category_id field
		$categoryForm = {
			category_id: categoryToEdit.category_id,
			category_name: categoryToEdit.category_name,
			category_description: categoryToEdit.category_description || '',
			parent_id: categoryToEdit.parent_id || '',
			is_public: Boolean(categoryToEdit.is_public)
		};
		
		// Show the form
		showCategoryForm = true;
		
		// Signal to the CategoryComponent that we've handled the edit event
		// This prevents the component from showing its own edit form
		window.dispatchEvent(new CustomEvent('category:edit:handled'));
	}
	
	// Function to handle part form updates 
	function updateFormData(event: CustomEvent<Record<string, any>>) {
		// Update the part form data with the values from the PartForm component
		if (event.detail) {
			console.log('Updating part form data:', event.detail);
			// Update the reactive store
			$partForm = {
				...$partForm,
				...event.detail
			};
		}
	}
	
	// Function to reset category form
	function resetCategoryForm() {
		// Reset the form with all fields from schema
		$categoryForm = {
			category_id: undefined, // Make sure it's properly cleared for new entries
			category_name: '',
			category_description: '',
			parent_id: '',
			is_public: false
		};
		
		// Reset edit mode
		editCategoryMode = false;
		currentCategoryId = null;
	}

	// Function to toggle category form visibility
	function toggleCategoryForm() {
		// Toggle the form visibility first
		showCategoryForm = !showCategoryForm;
		
		// If we're closing the form, reset everything
		if (!showCategoryForm) {
			// Reset edit mode
			editCategoryMode = false;
			currentCategoryId = null;
			
			// Reset form values
			$categoryForm = {
				category_name: '',
				category_description: '',
				parent_id: '',
				is_public: false
			} as CategoryFormType;
		} else if (showCategoryForm && !editCategoryMode) {
			// If we're opening the form for a new category
			editCategoryMode = false;
			currentCategoryId = null;
			// Reset form with type assertion
			$categoryForm = {
				category_name: '',
				category_description: '',
				parent_id: '',
				is_public: false
			} as CategoryFormType;
		}
	}
</script>

<div class="dashboard-container">
	<header class="dashboard-header">
		<div class="user-info">
			{#if user.avatar_url}
				<img class="avatar" src={user.avatar_url} alt="Avatar" />
			{:else}
				<div class="avatar-placeholder">{initial}</div>
			{/if}
			<div class="user-details">
				<h1 class="welcome">Welcome, {fullName}</h1>
				<button class="logout-button" on:click={() => goto('/logout')}>Logout</button>
			</div>
		</div>
	</header>

	<div class="dashboard-tabs">
		<button 
			class="tab-button {activeTab === 'projects' ? 'active' : ''}" 
			on:click={() => setActiveTab('projects')}
		>
			Projects
		</button>
		<button 
			class="tab-button {activeTab === 'parts' ? 'active' : ''}" 
			on:click={() => setActiveTab('parts')}
		>
			Parts
		</button>
		<button 
			class="tab-button {activeTab === 'manufacturers' ? 'active' : ''}" 
			on:click={() => setActiveTab('manufacturers')}
		>
			Manufacturers
		</button>
		<button 
			class="tab-button {activeTab === 'suppliers' ? 'active' : ''}" 
			on:click={() => setActiveTab('suppliers')}
		>
			Suppliers
		</button>
		<button 
			class="tab-button {activeTab === 'categories' ? 'active' : ''}" 
			on:click={() => setActiveTab('categories')}
		>
			Categories
		</button>
	</div>

	<section class="dashboard-content">
		<!-- Projects Tab -->
		{#if activeTab === 'projects'}
			<div class="tab-content">
				<h2>Your Projects</h2>
				{#if projects.length > 0}
					<ul class="projects-grid">
						{#each projects as project (project.project_id)}
							<li class="project-card">
								<a class="project-link" href={`/dashboard/${project.project_id}`}>{project.project_name}</a>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="no-items">You have no projects yet.</p>
				{/if}

				<h2>Add New Project</h2>
				<form class="project-form" method="POST" action="?/project">
					<input class="project-input" type="text" name="name" placeholder="Project Name" required />
					<button class="primary-btn" type="submit">Add Project</button>
				</form>
			</div>
		{/if}

		<!-- Parts Tab -->
		{#if activeTab === 'parts'}
			<div class="tab-content">
				<h2>Your Parts</h2>
				{#if userParts.length > 0}
					<div class="user-items-grid">
						{#each userParts as part (part.part_id)}
							<div class="entity-card">
								<h3>{(part as any).name || 'Unnamed Part'}</h3>
								<p class="entity-meta">Version: {(part as any).part_version || '1.0.0'}</p>
								<p class="entity-meta">Status: {part.lifecycle_status || 'Draft'}</p>
								<div class="entity-actions">
									<a href={`/parts/${part.part_id}`} class="icon-btn view-btn" title="View Part Details">👁️</a>
									<a href={`/parts/${part.part_id}/edit`} class="icon-btn edit-btn" title="Edit Part">✏️</a>
								</div>
							</div>
						{/each}
					</div>
				{:else}
					<p class="no-items">You haven't created any parts yet.</p>
				{/if}

				<div class="action-buttons">
					<button type="button" class="primary-btn" on:click={togglePartForm}>
						{showPartForm ? 'Cancel' : 'Add New Part'}
					</button>
					<a href="/parts" class="secondary-btn">View All Parts</a>
				</div>

				{#if showPartForm}
					<div class="form-container">
						<h2>Create New Part</h2>
						
						{#if $partMessage}
							<div class="form-message {typeof $partMessage === 'string' && $partMessage.includes('Failed') ? 'error' : 'success'}">
								{$partMessage}
							</div>
						{/if}
						
						<div class="embedded-form">
							<!-- Using bind:this to capture form element reference -->
							<form method="POST" action="?/part" use:partEnhance bind:this={partFormElement}>
								<!-- Hidden fields to capture form data from PartForm component -->
								{#each Object.entries($partForm) as [key, value]}
									{#if typeof value !== 'object' || value === null}
										<input type="hidden" name={key} value={value ?? ''} />
									{:else if key === 'dimensions' && value !== null}
										<!-- Handle dimensions object specially -->
										<input type="hidden" name="dimensions" value={JSON.stringify(value)} />
									{:else if typeof value === 'object'}
										<!-- Handle other object values -->
										<input type="hidden" name={key} value={JSON.stringify(value)} />
									{/if}
								{/each}

								<PartForm 
									categories={categories || []}
									errors={$partErrors as Record<string, any>}
									data={{ partForm: $partForm }}
									hideButtons={false}
									isDashboardContext={true}
									isEditMode={false}
									on:formUpdate={updateFormData}
								/>
								
								<div class="form-actions">
									<button type="submit" class="primary-btn" disabled={$partSubmitting}>
										{$partSubmitting ? 'Creating...' : 'Create Part'}
									</button>
									<button type="button" class="secondary-btn" on:click={togglePartForm}>Cancel</button>
								</div>
							</form>
						</div>
					</div>
				{/if}
			</div>
		{/if}

		<!-- Manufacturers Tab -->
		{#if activeTab === 'manufacturers'}
			<div class="tab-content">
				<!-- Hidden manufacturer form with SuperForm's enhance function -->
				<div class="hidden-form-container" style="display: none;" aria-hidden="true">
					<form method="POST" action="?/manufacturer" use:manufacturerEnhance id="manufacturer-hidden-form">
						<!-- Standard fields -->
						<input type="hidden" name="manufacturer_id" value={$manufacturerForm.manufacturer_id || ''} />
						<input type="hidden" name="manufacturer_name" value={$manufacturerForm.manufacturer_name || ''} />
						<input type="hidden" name="manufacturer_description" value={$manufacturerForm.manufacturer_description || ''} />
						<input type="hidden" name="website_url" value={$manufacturerForm.website_url || ''} />
						<input type="hidden" name="logo_url" value={$manufacturerForm.logo_url || ''} />
						
						<!-- Complex fields with special handling -->
						<input type="hidden" name="contact_info" value={typeof $manufacturerForm.contact_info === 'string' 
							? $manufacturerForm.contact_info 
							: JSON.stringify($manufacturerForm.contact_info || {})} />
						<input type="hidden" name="custom_fields" value={typeof $manufacturerForm.custom_fields === 'string' 
							? $manufacturerForm.custom_fields 
							: JSON.stringify($manufacturerForm.custom_fields || {})} />
						
						<!-- User tracking fields -->
						<input type="hidden" name="created_by" value={$manufacturerForm.created_by || user.user_id} />
						<input type="hidden" name="updated_by" value={user.user_id} />
						<button type="submit" id="manufacturer-submit-button">Submit</button>
					</form>
				</div>
				
				<ManufacturersTab 
					manufacturers={userManufacturers} 
					currentUserId={user.user_id}
					manufacturerForm={$manufacturerForm}
					manufacturerErrors={$manufacturerErrors || {}}
					showForm={showManufacturerForm}
					editMode={editManufacturerMode}
					on:submit={(event) => {
						console.log('Manufacturer form submitted:', event.detail);
						
						// Update the form data with the submitted values
						const formData = event.detail.formData;
						console.log('Received form data from component:', formData);
						
						// Ensure manufacturer_id is set correctly
						if (!editManufacturerMode || !formData.manufacturer_id) {
							// For new manufacturers, ensure ID is empty to generate a new one on the server
							formData.manufacturer_id = '';
						}
						
						// Update the form with the submitted values
						$manufacturerForm = {
							...formData,
							// Ensure required fields are set
							manufacturer_name: formData.manufacturer_name || '',
							// Handle custom_fields properly based on its type
							custom_fields: typeof formData.custom_fields === 'string' 
								? formData.custom_fields 
								: (formData.custom_fields ? JSON.stringify(formData.custom_fields) : '{}'),
							// Ensure user tracking fields are set
							created_by: editManufacturerMode ? $manufacturerForm.created_by : user.user_id,
							updated_by: user.user_id
						};
						
						// Validate that manufacturer_name is not empty
						if (!$manufacturerForm.manufacturer_name || $manufacturerForm.manufacturer_name.trim() === '') {
							console.error('Manufacturer name is required');
							return; // Don't proceed with submission if name is empty
						}
						
						// Use the hidden form with SuperForm's enhance function
						const hiddenForm = document.getElementById('manufacturer-hidden-form') as HTMLFormElement;
						if (hiddenForm) {
							// Update hidden form fields with current values
							Object.entries($manufacturerForm).forEach(([key, value]) => {
								const input = hiddenForm.querySelector(`[name="${key}"]`) as HTMLInputElement;
								if (input) {
									// Special handling for custom_fields and contact_info to ensure they remain as JSON strings
									if (key === 'custom_fields' || key === 'contact_info') {
										// If already a string, validate it's proper JSON
										if (typeof value === 'string') {
											try {
												// Validate it's proper JSON
												JSON.parse(value);
												input.value = value;
											} catch (e) {
												// If not valid JSON, use empty object
												console.error(`Invalid ${key} JSON:`, e);
												input.value = '{}';
											}
										} else if (typeof value === 'object' && value !== null) {
											// If it's an object, stringify it
											input.value = JSON.stringify(value);
										} else {
											// Default to empty object if null/undefined
											input.value = '{}';
										}
									} else if (typeof value === 'object' && value !== null) {
										// For other objects, stringify them
										input.value = JSON.stringify(value);
									} else {
										// For primitive values, convert to string
										input.value = value === null ? '' : String(value);
									}
									console.log(`Updated hidden form field: ${key} = ${input.value}`);
								}
							});
							
							// Find and click the submit button
							const submitButton = hiddenForm.querySelector('#manufacturer-submit-button') as HTMLButtonElement;
							if (submitButton) {
								console.log('Submitting hidden form with SuperForm enhance');
								submitButton.click();
							} else {
								console.error('Submit button not found in hidden form');
							}
						} else {
							console.error('Hidden manufacturer form not found');
						}
						
						// Reset UI state after submission
						showManufacturerForm = false;
						editManufacturerMode = false;
						currentManufacturerId = null;
						
						// Refresh data after a short delay
						setTimeout(() => refreshData(), 500);
						}}
						on:formUpdate={(event) => {
							console.log('Form update event received:', event.detail);
							
							// Update the form data when the form is changed
							if (event.detail && event.detail.data) {
								// Get the updated data from the event
								const formUpdateData = event.detail.data;
								
								// Create a new form object with the updated data
								const updatedForm = {
									...$manufacturerForm,
									...formUpdateData
								};
								
								console.log('Updated form data:', updatedForm);
								
								// Update the store with the new data
								$manufacturerForm = updatedForm;
							}
						}}
						on:cancelEdit={() => {
							console.log('Cancel edit event received');
							// Reset form and hide it
							showManufacturerForm = false;
							editManufacturerMode = false;
							currentManufacturerId = null;
							// Reset the form data
							$manufacturerForm = {
								manufacturer_id: '',
								manufacturer_name: '',
								manufacturer_description: '',
								website_url: '',
								logo_url: '',
								contact_info: '{}',
								custom_fields: '{}',
								created_by: user.user_id,
								updated_by: user.user_id,
								// Add these fields to satisfy TypeScript
								created_at: new Date(),
								updated_at: new Date()
							};
						}}
						on:refreshData={refreshData}
						on:toggleForm={() => {
							console.log('Toggle form event received, current state:', showManufacturerForm);
							// Toggle form visibility
							showManufacturerForm = !showManufacturerForm;
							// If closing the form, also reset edit mode
							if (!showManufacturerForm) {
								editManufacturerMode = false;
								currentManufacturerId = null;
								// Reset the form data
								$manufacturerForm = {
									manufacturer_id: '',
									manufacturer_name: '',
									manufacturer_description: '',
									website_url: '',
									logo_url: '',
									contact_info: '{}',
									custom_fields: '{}',
									created_by: user.user_id,
									updated_by: user.user_id,
									// Add these fields to satisfy TypeScript
									created_at: new Date(),
									updated_at: new Date()
								};
							} else {
								// If opening the form for a new manufacturer, ensure form is reset
								if (!editManufacturerMode) {
									$manufacturerForm = {
										manufacturer_id: '',
										manufacturer_name: '',
										manufacturer_description: '',
										website_url: '',
										logo_url: '',
										contact_info: '{}',
										custom_fields: '{}',
										created_by: user.user_id,
										updated_by: user.user_id,
										// Add these fields to satisfy TypeScript
										created_at: new Date(),
										updated_at: new Date()
									};
								}
							}
						}}
						on:editManufacturer={(event) => {
							console.log('Edit manufacturer event received:', event.detail);
							
							// Make sure we have manufacturer data
							const manufacturerToEdit = event.detail.manufacturer;
							if (!manufacturerToEdit) {
								console.error('No manufacturer data received in edit event');
								return;
							}
							
							// First, make the form visible
							showManufacturerForm = true;
							
							// Set up edit mode
							editManufacturerMode = true;
							currentManufacturerId = manufacturerToEdit.manufacturer_id;
							
							// Use the correct schema field names from manufacturerActionSchema
							console.log('Raw manufacturer data from server:', manufacturerToEdit);
							
							// Set the form data using the correct field names
							$manufacturerForm = {
								manufacturer_id: manufacturerToEdit.manufacturer_id,
								manufacturer_name: manufacturerToEdit.manufacturer_name,
								manufacturer_description: manufacturerToEdit.manufacturer_description || '',
								website_url: manufacturerToEdit.website_url || '',
								logo_url: manufacturerToEdit.logo_url || '',
								contact_info: typeof manufacturerToEdit.contact_info === 'object' 
									? JSON.stringify(manufacturerToEdit.contact_info)
									: manufacturerToEdit.contact_info || '{}',
								custom_fields: typeof manufacturerToEdit.custom_fields === 'object'
									? JSON.stringify(manufacturerToEdit.custom_fields)
									: manufacturerToEdit.custom_fields || '{}',
								created_by: manufacturerToEdit.created_by || user.user_id,
								updated_by: user.user_id,
								created_at: manufacturerToEdit.created_at || new Date(),
								updated_at: new Date()
							};
							
							console.log('Manufacturer form updated for editing, form state:', $manufacturerForm);
						}}
					/>
			</div>
		{/if}

		<!-- Suppliers Tab -->
		{#if activeTab === 'suppliers'}
			<div class="tab-content">
				<SuppliersTab
					suppliers={userSuppliers}
					currentUserId={user.user_id}
					showForm={showSupplierForm}
					editMode={editSupplierMode}
					supplierForm={$supplierForm}
					supplierErrors={$supplierErrors}
					on:submit={(event) => {
						console.log('Submit event received:', event.detail);
						$supplierForm = event.detail.formData;
						// Submit the form
						(document.getElementById('supplier-hidden-form') as HTMLFormElement)?.requestSubmit();
					}}
					on:editSupplier={(event) => {
						console.log('Edit supplier event received:', event.detail);
						// Set edit mode and prepare form data
						editSupplierMode = true;
						currentSupplierId = event.detail.supplier.supplier_id;
						
						// Update form with supplier data
						$supplierForm = {
							...$supplierForm,
							...event.detail.supplier
						};
						
						// Show the form
						showSupplierForm = true;
					}}
					on:toggleForm={() => {
						console.log('Toggle form event received, current state:', showSupplierForm);
						// Toggle form visibility
						showSupplierForm = !showSupplierForm;
						// If closing the form, also reset edit mode
						if (!showSupplierForm) {
							editSupplierMode = false;
							currentSupplierId = null;
							// Reset the form data
							$supplierForm = {
								supplier_id: '',
								supplier_name: '',
								supplier_description: '',
								website_url: '',
								logo_url: '',
								contact_info: '{}',
								custom_fields: '{}',
								created_by: user.user_id,
								updated_by: user.user_id,
								// Add these fields to satisfy TypeScript
								created_at: new Date(),
								updated_at: new Date()
							};
						} else {
							// If opening the form for a new supplier, ensure form is reset
							if (!editSupplierMode) {
								$supplierForm = {
									supplier_id: '',
									supplier_name: '',
									supplier_description: '',
									website_url: '',
									logo_url: '',
									contact_info: '{}',
									custom_fields: '{}',
									created_by: user.user_id,
									updated_by: user.user_id,
									// Add these fields to satisfy TypeScript
									created_at: new Date(),
									updated_at: new Date()
								};
							}
						}
					}}
					on:refreshData={refreshData}
					on:formUpdate={(event) => {
						console.log('Form update event received:', event.detail);
						
						// Update the form data when the form is changed
						if (event.detail && event.detail.data) {
							// Get the updated data from the event
							const formUpdateData = event.detail.data;
							
							// Create a new form object with the updated data
							const updatedForm = {
								...$supplierForm,
								...formUpdateData
							};
							
							console.log('Updated form data:', updatedForm);
							
							// Update the store with the new data
							$supplierForm = updatedForm;
						}
					}}
					on:cancelEdit={() => {
						console.log('Cancel edit event received');
						// Reset form and hide it
						showSupplierForm = false;
						editSupplierMode = false;
						currentSupplierId = null;
						// Reset the form data
						$supplierForm = {
							supplier_id: '',
							supplier_name: '',
							supplier_description: '',
							website_url: '',
							logo_url: '',
							contact_info: '{}',
							custom_fields: '{}',
							created_by: user.user_id,
							updated_by: user.user_id,
							// Add these fields to satisfy TypeScript
							created_at: new Date(),
							updated_at: new Date()
						};
					}}
				/>
				
				<!-- Manufacturer form using SuperForm for programmatic submission and validation -->
				<div hidden aria-hidden="true">
					<form method="POST" action="?/manufacturer" use:manufacturerEnhance id="manufacturer-hidden-form">
						<!-- Standard fields -->
						<input type="hidden" name="manufacturer_id" value={$manufacturerForm.manufacturer_id || ''} />
						<input type="hidden" name="manufacturer_name" value={$manufacturerForm.manufacturer_name || ''} />
						<input type="hidden" name="manufacturer_description" value={$manufacturerForm.manufacturer_description || ''} />
						<input type="hidden" name="website_url" value={$manufacturerForm.website_url || ''} />
						<input type="hidden" name="logo_url" value={$manufacturerForm.logo_url || ''} />
						
						<!-- Complex fields with special handling -->
						<input type="hidden" name="contact_info" value={typeof $manufacturerForm.contact_info === 'string' 
							? $manufacturerForm.contact_info 
							: JSON.stringify($manufacturerForm.contact_info || {})} />
						<input type="hidden" name="custom_fields" value={typeof $manufacturerForm.custom_fields === 'string' 
							? $manufacturerForm.custom_fields 
							: JSON.stringify($manufacturerForm.custom_fields || {})} />
						
						<!-- User tracking fields -->
						<input type="hidden" name="created_by" value={user.user_id} />
						<input type="hidden" name="updated_by" value={user.user_id} />
						<button type="submit" id="manufacturer-submit-button">Submit</button>
					</form>
				</div>

				<!-- Supplier Form using SuperForm pattern -->
				{#if showSupplierForm}
					<div class="entity-form">
						<h3>Add New Supplier</h3>
						
						{#if $supplierMessage}
							<div class="form-message {$supplierMessage.includes('Failed') ? 'error' : 'success'}">
								{$supplierMessage}
							</div>
						{/if}
						
						<form method="POST" action="?/supplier" use:supplierEnhance class="form-grid">
							<!-- Hidden supplier_id field for UUID -->
							<input type="hidden" name="supplier_id" bind:value={$supplierForm.supplier_id} />
							<div class="form-group">
								<label for="supplier-name" class="form-label">Name <span class="required">*</span></label>
								<input 
									id="supplier-name" 
									name="supplier_name" 
									bind:value={$supplierForm.supplier_name} 
									class="form-input enhanced-input"
									placeholder="Enter supplier name"
									required 
								/>
								{#if $supplierErrors.supplier_name}
									<span class="field-error">{$supplierErrors.supplier_name}</span>
								{/if}
							</div>
							
							<div class="form-group">
								<label for="supplier-description" class="form-label">Description</label>
								<textarea 
									id="supplier-description" 
									name="supplier_description" 
									bind:value={$supplierForm.supplier_description}
									class="form-textarea enhanced-textarea"
									placeholder="Enter supplier description"
									rows="3"
								></textarea>
								{#if $supplierErrors.supplier_description}
									<span class="field-error">{$supplierErrors.supplier_description}</span>
								{/if}
							</div>
							
							<div class="form-group">
								<label for="supplier-website" class="form-label">Website URL</label>
								<input 
									id="supplier-website" 
									name="website_url" 
									type="url" 
									bind:value={$supplierForm.website_url}
									class="form-input enhanced-input"
									placeholder="https://example.com"
								/>
								{#if $supplierErrors.website_url}
									<span class="field-error">{$supplierErrors.website_url}</span>
								{/if}
							</div>
							
							<div class="form-group">
								<label for="supplier-logo" class="form-label">Logo URL</label>
								<input 
									id="supplier-logo" 
									name="logo_url" 
									type="url" 
									bind:value={$supplierForm.logo_url}
									class="form-input enhanced-input"
									placeholder="https://example.com/logo.png"
								/>
								{#if $supplierErrors.logo_url}
									<span class="field-error">{$supplierErrors.logo_url}</span>
								{/if}
							</div>
							
							<div class="form-group">
								<label for="supplier-contact" class="form-label">Contact Info</label>
								<textarea 
									id="supplier-contact" 
									name="contact_info"
									bind:value={$supplierForm.contact_info}
									class="form-textarea enhanced-textarea"
									placeholder="Enter contact information"
									rows="3"
								></textarea>
								<small class="helper-text">
									Enter as JSON: {@html '{ "email": "contact@example.com", "phone": "123-456-7890" }'}
								</small>
								{#if $supplierErrors.contact_info}
									<span class="field-error">{$supplierErrors.contact_info}</span>
								{/if}
							</div>
							
							<div class="form-actions">
								<button type="submit" class="primary-btn" disabled={$supplierSubmitting}>
									{$supplierSubmitting ? 'Creating...' : 'Create Supplier'}
								</button>
								<button type="button" class="secondary-btn" on:click={() => showSupplierForm = false}>Cancel</button>
							</div>
						</form>
					</div>
				{/if}
			</div>
		{/if}

		<!-- Categories Tab -->
		{#if activeTab === 'categories'}
			<div class="tab-content">
				<h2>Your Categories</h2>
				
				<!-- No duplicate form here -->

				<!-- User's categories list -->
				{#if transformedCategories.length > 0}
						<div class="user-items-grid">
							{#each transformedCategories as category}
								<CategoryComponent 
									category={category} 
									allowEdit={user.user_id === category.created_by} 
									allowDelete={user.user_id === category.created_by}
									on:deleted={handleCategoryDeleted}
									on:edit={handleCategoryEdit}
							/>
						{/each}
					</div>
				{:else}
					<p class="no-items">You haven't created any categories yet.</p>
				{/if}
				
				<div class="action-buttons">
					<button type="button" class="primary-btn" on:click={toggleCategoryForm}>
						{showCategoryForm ? 'Hide Form' : 'Add New Category'}
					</button>
					<a href="/category" class="secondary-btn">View All Categories</a>
				</div>
				
				{#if showCategoryForm}
					<div class="form-container">
						<h2>{editCategoryMode ? 'Edit' : 'Create New'} Category</h2>
						
						{#if $categoryMessage}
							<div class="form-message {$categoryMessage.includes('Failed') ? 'error' : 'success'}">
								{$categoryMessage}
							</div>
						{/if}
						
						<div class="embedded-form">
							<form method="POST" action="?/category" use:categoryEnhance enctype="application/x-www-form-urlencoded">
								<!-- We need to conditionally add category_id only when in edit mode -->
								{#if editCategoryMode}
									<input type="hidden" name="category_id" value={currentCategoryId} />
								{/if}
								<div class="form-group">
									<label for="category_name">Name*</label>
									<input id="category_name" name="category_name" bind:value={$categoryForm.category_name} required />
									{#if $categoryErrors.category_name}<span class="error">{$categoryErrors.category_name}</span>{/if}
								</div>
								
								<div class="form-group">
									<label for="parent_id">Parent Category</label>
									<CategoryComboBox 
										categories={categories} 
										bind:value={$categoryForm.parent_id} 
										name="parent_id" 
										placeholder="Select parent category..." 
									/>
									{#if $categoryErrors.parent_id}<span class="error">{$categoryErrors.parent_id}</span>{/if}
								</div>
								
								<div class="form-group">
									<label for="category_description">Description</label>
									<textarea id="category_description" name="category_description" bind:value={$categoryForm.category_description}></textarea>
									{#if $categoryErrors.category_description}<span class="error">{$categoryErrors.category_description}</span>{/if}
								</div>
								
								<div class="form-group checkbox-group">
									<label>
										<input type="checkbox" name="is_public" bind:checked={$categoryForm.is_public} /> 
										Public
									</label>
									{#if $categoryErrors.is_public}<span class="error">{$categoryErrors.is_public}</span>{/if}
								</div>
								
								<div class="form-button-group">
									<button type="submit" class="primary-btn" disabled={$categorySubmitting}>
										{$categorySubmitting ? (editCategoryMode ? 'Saving...' : 'Creating...') : (editCategoryMode ? 'Save Changes' : 'Create Category')}
									</button>
									<button type="button" class="secondary-btn" on:click={() => {
									resetCategoryForm();
									showCategoryForm = false;
								}}>Cancel</button>
								</div>
							</form>
						</div>
					</div>
				{/if}
			</div>
		{/if}
	</section>
</div>

<style lang="postcss">
	.dashboard-container {
		max-width: 1000px;
		margin: 2rem auto;
		padding: 0;
		color: hsl(var(--foreground));
		transition: color 0.3s, background-color 0.3s, border-color 0.3s;
	}

	.dashboard-header {
		display: flex;
		align-items: center;
		justify-content: space-between;
		padding: 1rem 2rem;
		background: linear-gradient(135deg, hsl(var(--primary-dark)), hsl(var(--primary)));
		border-radius: 8px 8px 0 0;
		color: hsl(var(--primary-foreground));
	}

	.user-info {
		display: flex;
		align-items: center;
		gap: 1rem;
	}

	.avatar {
		width: 50px;
		height: 50px;
		border-radius: 50%;
		object-fit: cover;
	}

	.avatar-placeholder {
		width: 50px;
		height: 50px;
		background: hsl(var(--muted));
		border-radius: 50%;
		display: flex;
		align-items: center;
		justify-content: center;
		font-weight: bold;
		color: hsl(var(--muted-foreground));
	}



	.user-details {
		display: flex;
		align-items: center;
		gap: 1rem;
	}

	.welcome {
		margin: 0;
		font-size: 1.5rem;
	}

	.logout-button {
		background: hsl(var(--background));
		color: hsl(var(--primary-dark));
		border: none;
		padding: 0.5rem 1rem;
		border-radius: 4px;
		cursor: pointer;
		transition: background-color 0.3s, color 0.3s;
	}

	.logout-button:hover {
		background: hsl(var(--muted));
	}

	/* Dashboard Tabs Styling */
	.dashboard-tabs {
		display: flex;
		justify-content: space-between;
		background: hsl(var(--surface-100));
		border-bottom: 1px solid hsl(var(--border));
	}

	.tab-button {
		flex: 1;
		padding: 1rem 0.5rem;
		background: transparent;
		border: none;
		border-bottom: 2px solid transparent;
		cursor: pointer;
		font-weight: 600;
		transition: all 0.2s ease;
		color: hsl(var(--muted-foreground));
	}

	.tab-button:hover {
		background: hsl(var(--muted));
		color: hsl(var(--primary));
	}

	.tab-button.active {
		border-bottom: 2px solid hsl(var(--primary));
		color: hsl(var(--primary));
	}

	/* Dashboard Content Styling */
	.dashboard-content {
		background: hsl(var(--background));
		padding: 2rem;
		border-radius: 0 0 8px 8px;
		box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
		transition: background-color 0.3s, color 0.3s;
	}

	.tab-content {
		animation: fadeIn 0.3s ease;
	}

	@keyframes fadeIn {
		from { opacity: 0; }
		to { opacity: 1; }
	}

	.tab-content h2 {
		margin-top: 0;
		color: hsl(var(--foreground));
		margin-bottom: 1.5rem;
	}

	.projects-grid {
		display: grid;
		grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
		gap: 1rem;
		margin: 1rem 0 2rem 0;
	}

	.user-items-grid {
		display: grid;
		grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
		gap: 1.5rem;
		margin: 1rem 0 2rem 0;
	}

	.project-card {
		background: hsl(var(--surface-100));
		padding: 1rem;
		border-radius: 8px;
		text-align: center;
		transition: box-shadow 0.3s, border-color 0.3s, background-color 0.3s;
		border: 1px solid hsl(var(--border));
	}

	.project-card:hover {
		box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
		border-color: hsl(var(--primary));
	}

	.project-link {
		color: hsl(var(--primary));
		font-weight: bold;
		text-decoration: none;
	}

	.project-link:hover {
		text-decoration: underline;
	}

	.no-items {
		color: hsl(var(--muted-foreground));
		font-style: italic;
		padding: 1rem;
		background: hsl(var(--surface-100));
		border-radius: 8px;
		text-align: center;
		margin-bottom: 2rem;
	}

	.form-container {
		margin-top: 2rem;
		padding: 2rem;
		background: hsl(var(--surface-100));
		border-radius: 12px;
		border: 1px solid hsl(var(--border));
		box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);
		transition: background-color 0.3s, border-color 0.3s;
	}

	.form-container h2 {
		margin-top: 0;
		margin-bottom: 1rem;
		color: hsl(var(--foreground));
		border-bottom: 1px solid hsl(var(--border));
		padding-bottom: 0.5rem;
	}

	.embedded-form {
		margin-top: 1rem;
	}

	.form-message {
		padding: 0.75rem 1rem;
		border-radius: 6px;
		margin-bottom: 1rem;
		transition: background-color 0.3s, color 0.3s, border-color 0.3s;
		background-color: hsl(var(--surface-100));
		border: 1px solid hsl(var(--border));
		color: hsl(var(--foreground));
	}

	.form-message.success {
		background: hsl(var(--success) / 0.2);
		border: 1px solid hsl(var(--success));
		color: hsl(var(--success));
	}

	.form-message.error {
		background: hsl(var(--destructive) / 0.2);
		border: 1px solid hsl(var(--destructive));
		color: hsl(var(--destructive));
	}

	.entity-card {
		background: hsl(var(--card));
		border-radius: 8px;
		padding: 1.25rem;
		box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
		display: flex;
		gap: 1rem;
		transition: box-shadow 0.3s, transform 0.2s, background-color 0.3s, border-color 0.3s;
		border: 1px solid hsl(var(--border));
		position: relative;
	}

	.entity-card:hover {
		box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
		transform: translateY(-2px);
		border-color: hsl(var(--card-hover-border));
	}

	.entity-card h3 {
		margin-top: 0;
		margin-bottom: 0.5rem;
		font-size: 1.1rem;
		color: hsl(var(--card-foreground));
	}

	.entity-meta {
		margin-bottom: 0.5rem;
		color: hsl(var(--muted-foreground));
		font-size: 0.875rem;
	}

	

	
	/* Contact styling moved to component level for better modularity */


	.icon-btn {
		padding: 0.25rem 0.5rem;
		border-radius: 4px;
		font-size: 1rem;
		transition: all 0.2s ease;
		text-decoration: none;
	}

	.view-btn:hover {
		background: hsl(var(--muted));
	}

	.edit-btn:hover {
		background: hsl(var(--primary) / 0.1);
	}

	.project-form {
		display: flex;
		gap: 1rem;
		margin-top: 1rem;
	}

	.project-input {
		flex: 1;
		padding: 0.75rem;
		border: 1px solid hsl(var(--input-border));
		border-radius: 6px;
		font-size: 1rem;
	}

	.action-buttons {
		display: flex;
		gap: 1rem;
		margin-top: 1.5rem;
	}

	.form-grid {
		display: grid;
		gap: 1.5rem;
	}

	.form-group {
		display: flex;
		flex-direction: column;
		gap: 0.5rem;
	}

	.form-input, .form-textarea {
		padding: 0.75rem;
		border: 1px solid hsl(var(--input-border));
		border-radius: 6px;
		font-size: 1rem;
		transition: all 0.2s ease;
		width: 100%;
	}

	.form-input:focus, .form-textarea:focus {
		outline: none;
		border-color: hsl(var(--ring));
		box-shadow: 0 0 0 2px hsl(var(--ring) / 0.2);
	}

	.enhanced-input {
		border: 1px solid hsl(var(--input-border));
		border-radius: 6px;
		padding: 0.75rem;
		font-size: 1rem;
		background-color: hsl(var(--input));
		color: hsl(var(--input-foreground));
		transition: border-color 0.15s, background-color 0.3s, color 0.3s;
	}

	.enhanced-input:focus {
		outline: none;
		border-color: hsl(var(--ring));
		box-shadow: 0 0 0 2px hsl(var(--ring) / 0.2);
	}

	.enhanced-input::placeholder {
		color: hsl(var(--muted-foreground));
	}


	.form-textarea {
		resize: vertical;
		min-height: 100px;
	}

	.form-actions {
		margin-top: 1.5rem;
		display: flex;
		justify-content: flex-end;
		gap: 0.75rem;
	}

	.field-error {
		color: hsl(var(--destructive));
		font-size: 0.875rem;
		padding: 0.25rem 0.5rem;
		background: hsl(var(--destructive) / 0.2);
		border-radius: 4px;
		border: 1px solid hsl(var(--destructive));
	}

	.required {
		color: hsl(var(--destructive));
	}

	.primary-btn {
		background: hsl(var(--primary));
		color: hsl(var(--primary-foreground));
		border: none;
		padding: 0.75rem 1.5rem;
		border-radius: 6px;
		font-weight: 500;
		cursor: pointer;
		transition: background-color 0.3s;
	}

	.primary-btn:hover {
		background: hsl(var(--primary-dark));
	}



	
	


	.secondary-btn {
		background: hsl(var(--background));
		color: hsl(var(--primary));
		border: 1px solid hsl(var(--primary));
		padding: 0.75rem 1.5rem;
		border-radius: 6px;
		cursor: pointer;
		transition: all 0.2s ease;
		font-weight: 600;
		text-decoration: none;
		display: inline-flex;
		align-items: center;
		justify-content: center;
	}

	.secondary-btn:hover {
		background: hsl(var(--primary) / 0.1);
		transform: translateY(-1px);
	}

	@media (max-width: 768px) {
		.dashboard-tabs {
			flex-wrap: wrap;
		}

		.tab-button {
			flex: 1 0 33.333%;
			padding: 0.75rem 0.5rem;
		}

		.action-buttons {
			flex-direction: column;
		}
	}

	@media (max-width: 600px) {
		.dashboard-header {
			flex-direction: column;
			gap: 1rem;
		}

		.tab-button {
			flex: 1 0 50%;
			font-size: 0.9rem;
		}

		.dashboard-content {
			padding: 1.25rem;
		}

		.projects-grid,
		.user-items-grid {
			grid-template-columns: 1fr;
		}
	}
</style>
